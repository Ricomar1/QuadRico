<!DOCTYPE html>
<html lang="fr" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>QuadRico ‚Äì G√©n√©rateur de quadrillage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* PALETTES TH√àME */
    :root[data-theme="dark"] {
      --bg-main: #080a0f;
      --bg-panel: #151821;
      --border-panel: #2b3140;
      --text-main: #f5f5f7;
      --text-sub: #c3c7d1;
      --accent: #2f81ff;
      --accent-soft: rgba(47,129,255,0.15);
      --danger: #ff4b5c;
      --btn-bg: #1e2330;
      --btn-bg-hover: #272d3c;
      --canvas-bg: #000000;
    }

    :root[data-theme="light"] {
      --bg-main: #f4f5f8;
      --bg-panel: #ffffff;
      --border-panel: #d3d7e2;
      --text-main: #111827;
      --text-sub: #4b5563;
      --accent: #2563eb;
      --accent-soft: rgba(37,99,235,0.08);
      --danger: #dc2626;
      --btn-bg: #f3f4f6;
      --btn-bg-hover: #e5e7eb;
      --canvas-bg: #ffffff;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: radial-gradient(circle at top left, #141b2b 0, #080a0f 45%, #050609 100%);
      color: var(--text-main);
      transition: background 0.25s ease, color 0.25s ease;
      overflow-x: hidden;
      overflow-y: auto;
    }

    :root[data-theme="light"] body {
      background: #e5e7eb;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      background: #111522;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      overflow: hidden;
      border: 1px solid #28324a;
      box-shadow: 0 0 12px rgba(0,0,0,0.6);
    }

    :root[data-theme="light"] .logo-mark {
      background: #ffffff;
      border-color: #cbd5f5;
      box-shadow: 0 0 8px rgba(148,163,184,0.6);
    }

    .logo-cell { width: 100%; height: 100%; }
    .logo-yellow { background: #ffd54a; }
    .logo-blue   { background: #4aa3ff; }
    .logo-green  { background: #4adf7c; }
    .logo-red    { background: #ff5f5f; }

    .logo-text {
      display: flex;
      flex-direction: column;
      line-height: 1.1;
    }
    .logo-text-main {
      font-weight: 600;
      font-size: 22px;
      letter-spacing: 0.05em;
    }
    .logo-text-sub {
      font-size: 12px;
      color: var(--text-sub);
    }

    /* BARRE PRINCIPALE (3 LIGNES) */

    .top-bar-main {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin: 10px 0 6px 0;
    }

    .contact-info {
      font-size: 12px;
      color: var(--text-sub);
      text-align: center;
      min-height: 16px;
      white-space: normal;
    }

    .system-icons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .top-icon-btn {
      min-width: auto;
      padding: 10px 14px;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.45);
    }

    :root[data-theme="light"] .top-icon-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 7px rgba(148,163,184,0.75);
    }

    .top-icon-btn:hover {
      background: var(--btn-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    }

    .top-icon-btn.reset      { border-color: var(--danger); }
    .top-icon-btn.printA4    { border-color: #4adf7c; }
    .top-icon-btn.printA3    { border-color: #22c55e; }
    .top-icon-btn.download   { border-color: var(--accent); }
    .top-icon-btn.contact    { border-color: #facc15; }
    .top-icon-btn.briefing   { border-color: #a855f7; }
    .top-icon-btn.save       { border-color: #22c55e; }
    .top-icon-btn.load       { border-color: #3b82f6; }
    .top-icon-btn.help       { border-color: #e5e7eb; }

    #optionsToggle {
      display: none;
    }

    .icon-hint {
      font-size: 12px;
      color: var(--text-sub);
      min-height: 16px;
      text-align: center;
    }

    /* Ligne Source + mid-box + Zoom */
    .source-zoom-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }

    .source-box,
    .zoom-box,
    .mid-box {
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.35);
      min-width: 230px;
    }

    :root[data-theme="light"] .source-box,
    :root[data-theme="light"] .zoom-box,
    :root[data-theme="light"] .mid-box {
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    .source-box strong,
    .zoom-box strong,
    .mid-box strong {
      display: block;
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 4px;
      text-align: center;
    }

    .source-box label,
    .mid-box label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }

    .source-box input[type="file"] {
      color: var(--text-sub);
      max-width: 180px;
    }

    .zoom-box label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }

    #zoomRange {
      width: 120px;
      margin-left: 4px;
    }

    #zoomNumber {
      width: 60px;
      margin-left: 6px;
      background: #090c14;
      border: 1px solid #32394b;
      border-radius: 6px;
      color: var(--text-main);
      padding: 2px 6px;
    }

    :root[data-theme="light"] #zoomNumber {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    /* Toolbar APPLIQUER / SUPPRIMER ‚Äì STICKY */

    .toolbar-main {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;

      position: sticky;
      top: 0;
      z-index: 500;

      background: radial-gradient(circle at top, rgba(8,10,15,0.98), rgba(8,10,15,0.95));
      padding: 6px 14px;
      margin-bottom: 8px;
      border-radius: 999px;
      border: 1px solid rgba(60,68,90,0.9);
      box-shadow: 0 4px 16px rgba(0,0,0,0.7);
    }

    :root[data-theme="light"] .toolbar-main {
      background: rgba(249,250,251,0.96);
      border-color: #d1d5db;
      box-shadow: 0 4px 12px rgba(148,163,184,0.8);
    }

    .toolbar-main button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .toolbar-main .undo-redo-btn {
      padding: 10px 14px;
      font-size: 18px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      min-width: 50px;
    }

    .toolbar-main .undo-redo-btn:hover {
      background: var(--btn-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }

    :root[data-theme="light"] .toolbar-main .undo-redo-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    #drawBtn {
      font-size: 17px;
      font-weight: 600;
      min-width: 180px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid var(--accent);
      background: var(--accent-soft);
      color: var(--text-main);
      box-shadow: 0 0 10px rgba(30,64,175,0.8);
    }

    #drawBtn:hover {
      background: rgba(47,129,255,0.23);
      transform: translateY(-1px);
    }

    #undoDeleteBtn {
      font-size: 14px;
      min-width: 150px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
    }

    :root[data-theme="light"] #undoDeleteBtn {
      border-color: #d1d5db;
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    #undoDeleteBtn:hover {
      background: var(--btn-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }

    /* LAYOUT PRINCIPAL */

    .main-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      margin-top: 10px;
    }

    .canvas-wrapper {
      flex: 1;
      min-width: 300px;
      position: relative;
    }

    .canvas-scroll {
      overflow: visible;
      border-radius: 8px;
    }

    .side-panel {
      flex: 0 0 480px;
      max-width: 500px;
      align-self: flex-start;
      position: sticky;
      top: 0;
      z-index: 400;
    }

    /* Mode briefing */
    body.briefing-mode .side-panel {
      display: none;
    }
    body.briefing-mode .canvas-wrapper {
      flex: 1 1 auto;
    }

    /* BLOC OPTIONS */
    .controls {
      display: grid;
      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
      gap: 8px;
      background: var(--bg-panel);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border-panel);
      box-shadow: 0 0 16px rgba(0,0,0,0.45);
    }

    :root[data-theme="light"] .controls {
      box-shadow: 0 4px 10px rgba(148,163,184,0.45);
    }

    label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }

    input[type="number"],
    input[type="range"],
    select,
    input[type="text"] {
      font-size: 13px;
    }

    input[type="number"] {
      margin-left: 4px;
      background: #090c14;
      border: 1px solid #32394b;
      border-radius: 6px;
      color: var(--text-main);
      padding: 2px 6px;
      width: 60px;
    }

    :root[data-theme="light"] input[type="number"] {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    input[type="range"] {
      width: 120px;
      margin-left: 4px;
    }

    select {
      margin-left: 4px;
      padding: 2px 4px;
      border-radius: 6px;
      border: 1px solid #32394b;
      background: #090c14;
      color: var(--text-main);
    }

    :root[data-theme="light"] select {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    input[type="text"] {
      margin-left: 4px;
      padding: 2px 4px;
      border-radius: 6px;
      border: 1px solid #32394b;
      background: #090c14;
      color: var(--text-main);
      width: 130px;
    }

    :root[data-theme="light"] input[type="text"] {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    .group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 13px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(7, 10, 18, 0.7);
      border: 1px solid rgba(60,68,90,0.9);
    }

    :root[data-theme="light"] .group {
      background: #f9fafb;
      border-color: #d1d5db;
    }

    .group strong {
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 1px;
      white-space: nowrap;
    }

    .group-full {
      grid-column: 1 / -1;
    }

    .selection-modes,
    .selection-modes-second {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: nowrap;
      justify-content: flex-start;
    }

    .selection-mode-btn {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 6px rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }

    :root[data-theme="light"] .selection-mode-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 4px rgba(148,163,184,0.6);
    }

    .selection-mode-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .selection-mode-btn span.icon {
      font-size: 14px;
    }

    .border-width-options {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
    }

    .border-width-options span.label-title {
      color: var(--text-sub);
      font-size: 12px;
      margin-right: 4px;
      white-space: nowrap;
    }

    canvas {
      border: 1px solid #3a4158;
      display: block;
      margin-top: 12px;
      background: var(--canvas-bg);
      transition: background 0.25s ease, border-color 0.25s ease;
      max-width: 100%;
    }

    :root[data-theme="light"] canvas {
      border-color: #cbd5e1;
    }

    #msg {
      margin-top: 8px;
      font-size: 12px;
      color: #ffb74d;
    }

    :root[data-theme="light"] #msg {
      color: #b45309;
    }

    footer {
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-sub);
      text-align: center;
    }

    /* AIDE / MODAL */

    .hidden {
      display: none;
    }

    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .help-modal {
      position: relative;
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 12px;
      padding: 16px 20px 14px 20px;
      max-width: 480px;
      width: 90%;
      box-shadow: 0 12px 30px rgba(0,0,0,0.7);
    }

    .help-modal h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: var(--accent);
    }

    .help-modal h3 {
      margin: 8px 0 4px 0;
      font-size: 14px;
      color: var(--text-main);
    }

    .help-modal p,
    .help-modal li {
      font-size: 13px;
      color: var(--text-sub);
      line-height: 1.4;
    }

    .help-modal ul {
      padding-left: 18px;
      margin: 4px 0 6px 0;
    }

    .help-close {
      border: none;
      background: transparent;
      color: var(--text-sub);
      font-size: 18px;
      cursor: pointer;
      position: absolute;
      top: 6px;
      right: 8px;
    }

    .help-close:hover {
      color: var(--text-main);
    }

    /* ===================== RESPONSIVE T√âL√âPHONE ===================== */

    @media (max-width: 900px) {
      body {
        margin: 10px;
      }

      .main-layout {
        flex-direction: column;
      }

      .canvas-wrapper {
        width: 100%;
      }

      .side-panel {
        position: static;
        width: 100%;
        max-width: 100%;
        margin-top: 10px;
        display: flex;
        justify-content: center;
      }

      body.options-collapsed .side-panel {
        display: none;
      }

      .zoom-box {
        display: none;
      }

      .controls {
        grid-template-columns: 1fr;
        transform: scale(0.95);
        transform-origin: top center;
        margin: 0 auto;
      }

      .toolbar-main {
        top: 0;
        border-radius: 10px;
        justify-content: center;
      }
      .toolbar-main #undoBtn,
      .toolbar-main #redoBtn,
      .toolbar-main #undoDeleteBtn {
        order: 1;
      }
      .toolbar-main #drawBtn {
        order: 2;
        flex-basis: 100%;
        max-width: 230px;
        justify-content: center;
      }

      .source-zoom-row {
        flex-direction: column;
        align-items: stretch;
      }
      .source-box,
      .mid-box {
        width: 100%;
      }

      .system-icons {
        justify-content: center;
      }

      #optionsToggle {
        display: inline-flex;
      }

      label {
        font-size: 12px;
      }
      .group {
        font-size: 12px;
      }

      canvas {
        height: auto;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo-mark">
      <div class="logo-cell logo-yellow"></div>
      <div class="logo-cell logo-blue"></div>
      <div class="logo-cell logo-green"></div>
      <div class="logo-cell logo-red"></div>
    </div>
    <div class="logo-text">
      <div class="logo-text-main">QuadRico</div>
      <div class="logo-text-sub">G√©n√©rateur de quadrillage tactique</div>
    </div>
  </header>

  <div class="top-bar-main">
    <div id="contactInfo" class="contact-info"></div>

    <div class="system-icons">
      <button id="themeToggle" class="top-icon-btn" aria-label="Basculer mode jour/sombre">
        <span class="theme-toggle-icon">‚òØ</span>
      </button>
      <button id="orientationToggle" class="top-icon-btn" aria-label="Portrait / Paysage">
        üñºÔ∏è‚Üï
      </button>
      <button id="fullscreenToggle" class="top-icon-btn" aria-label="Basculer plein √©cran">
        ‚õ∂
      </button>
      <button id="briefingBtn" class="top-icon-btn briefing" aria-label="Mode briefing">
        üé¨
      </button>
      <button id="saveScenarioBtn" class="top-icon-btn save" aria-label="Sauvegarder sc√©nario">
        üíæ
      </button>
      <button id="loadScenarioBtn" class="top-icon-btn load" aria-label="Charger sc√©nario">
        üìÇ
      </button>
      <button id="helpBtn" class="top-icon-btn help" aria-label="Aide / guide rapide">
        ‚ùì
      </button>
      <button id="printBtn" class="top-icon-btn printA4" aria-label="Imprimer A4">
        üñ® A4
      </button>
      <button id="printA3Btn" class="top-icon-btn printA3" aria-label="Imprimer A3">
        üñ® A3
      </button>
      <button id="downloadBtn" class="top-icon-btn download" aria-label="T√©l√©charger PNG" disabled>
        ‚¨á
      </button>
      <button id="resetBtn" class="top-icon-btn reset" aria-label="Effacer / Reset">
        üóë
      </button>
      <button id="contactBtn" class="top-icon-btn contact" aria-label="Contact">
        ‚úâ
      </button>
      <button id="optionsToggle" class="top-icon-btn" aria-label="Afficher / masquer les options">
        ‚öô Options
      </button>
    </div>

    <div id="iconHint" class="icon-hint"></div>

    <div class="source-zoom-row">
      <div class="source-box">
        <strong>Source</strong>
        <label>
          <span>Image :</span>
          <input type="file" id="imageLoader" accept="image/*">
        </label>
      </div>

      <div class="mid-box">
        <strong>Param√®tres de grille</strong>
        <label>
          <span>Grille sans image</span>
          <input type="checkbox" id="gridOnly">
        </label>
        <label>
          <span>Colonnes :</span>
          <input type="number" id="cols" value="10" min="1">
        </label>
        <label>
          <span>Lignes :</span>
          <input type="number" id="rows" value="14" min="1">
        </label>
      </div>

      <div class="mid-box">
        <strong>L√©gende</strong>
        <label>
          <span>Pas de l√©gende</span>
          <input type="radio" name="legendMode" value="none">
        </label>
        <label>
          <span>L√©gende partielle</span>
          <input type="radio" name="legendMode" value="partial">
        </label>
        <label>
          <span>L√©gende totale (4 c√¥t√©s)</span>
          <input type="radio" name="legendMode" value="full" checked>
        </label>
      </div>

      <div class="zoom-box">
        <strong>Zoom & vue</strong>
        <label>
          <span>Zoom :</span>
          <span>
            <input type="range" id="zoomRange" min="50" max="300" value="100">
            <span id="zoomValue">100%</span>
            <input type="number" id="zoomNumber" min="50" max="300" value="100">
          </span>
        </label>
      </div>
    </div>
  </div>

  <div class="main-layout">
    <div class="canvas-wrapper">
      <div class="toolbar-main">
        <button id="undoBtn" class="undo-redo-btn" title="Retour en arri√®re">
          ‚Ü©
        </button>
        <button id="redoBtn" class="undo-redo-btn" title="Retour en avant">
          ‚Ü™
        </button>
        <button id="undoDeleteBtn">
          SUPPRIMER
        </button>
        <button id="drawBtn">
          APPLIQUER
        </button>
      </div>

      <div class="canvas-scroll">
        <canvas id="canvas"></canvas>
      </div>
      <div id="msg"></div>
    </div>

    <div class="side-panel">
      <div class="controls">
        <div class="group group-full">
          <strong>Rafra√Æchissement auto :</strong>
          <label>
            <span>Appliquer automatiquement les modifications</span>
            <input type="checkbox" id="autoRefresh">
          </label>
        </div>

        <div class="group">
          <strong>Choix du type de quadrillage :</strong>
          <label>
            <span>Aucun</span>
            <input type="radio" name="gridType" value="none">
          </label>
          <label>
            <span>Noir</span>
            <input type="radio" name="gridType" value="uni-black">
          </label>
          <label>
            <span>Rouge</span>
            <input type="radio" name="gridType" value="uni-red">
          </label>
          <label>
            <span>FSI (4 couleurs)</span>
            <input type="radio" name="gridType" value="fsi" checked>
          </label>
        </div>

        <div class="group">
          <strong>Choix du type de code dans les cases :</strong>
          <label>
            <span>Aucun code</span>
            <input type="radio" name="labelMode" value="none" checked>
          </label>
          <label>
            <span>Code noir</span>
            <input type="radio" name="labelMode" value="uni">
          </label>
          <label>
            <span>Code rouge</span>
            <input type="radio" name="labelMode" value="color">
          </label>
          <label>
            <span>Code FSI</span>
            <input type="radio" name="labelMode" value="fsi-color">
          </label>
        </div>

        <div class="group">
          <strong>Style des lignes :</strong>
          <label>
            <span>Pointill√©s</span>
            <input type="checkbox" id="dashedLines">
          </label>
          <label>
            <span>Croix (noir)</span>
            <input type="checkbox" id="crossBlack">
          </label>
          <label>
            <span>Croix (rouge)</span>
            <input type="checkbox" id="crossRed">
          </label>
          <label>
            <span>Croix (FSI)</span>
            <input type="checkbox" id="crossFSI">
          </label>
        </div>

        <div class="group">
          <strong>Opacit√© :</strong>
          <label>
            <span>Image :</span>
            <input type="range" id="imageOpacity" min="0" max="100" value="100">
          </label>
          <label>
            <span>Quadrillage :</span>
            <input type="range" id="gridOpacity" min="0" max="100" value="100">
          </label>
          <label>
            <span>Code / Croix :</span>
            <input type="range" id="codeOpacity" min="0" max="100" value="100">
          </label>
        </div>

        <div class="group group-full">
          <strong>S√©lection de case :</strong>
          <label>
            <span>Activer la s√©lection de cases</span>
            <input type="checkbox" id="selectionMode">
          </label>

          <div class="selection-modes">
            <button id="modeApply" class="selection-mode-btn active" type="button" title="Appliquer sur la case">
              <span class="icon">‚úé</span> Appliquer
            </button>
            <button id="modeEraseBorder" class="selection-mode-btn" type="button" title="Effacer bordure / quadrillage">
              <span class="icon">‚¨ö</span> Effacer bordure
            </button>
            <button id="modeEraseCode" class="selection-mode-btn" type="button" title="Effacer texte / croix">
              <span class="icon">‚úï</span> Effacer texte/croix
            </button>
          </div>

          <div class="selection-modes-second">
            <button id="modeMerge" class="selection-mode-btn" type="button" title="Fusionner les cases">
              <span class="icon">‚ñ©</span> Fusionner
            </button>
            <button id="modeSplit" class="selection-mode-btn" type="button" title="Fractionner les cases">
              <span class="icon">‚ñ¢</span> Fractionner
            </button>
          </div>

          <div class="border-width-options">
            <span class="label-title">√âpaisseur du trait :</span>
            <label>
              <span>Normal</span>
              <input type="radio" name="borderWidth" value="normal" checked>
            </label>
            <label>
              <span>√âpais</span>
              <input type="radio" name="borderWidth" value="epais">
            </label>
            <label>
              <span>Tr√®s √©pais</span>
              <input type="radio" name="borderWidth" value="tres-epais">
            </label>
          </div>

          <label>
            <span>Couleur de bordure :</span>
            <select id="borderColor">
              <option value="#000000">Noir</option>
              <option value="#ff0000">Rouge</option>
              <option value="#0000ff">Bleu</option>
              <option value="#00aa00">Vert</option>
              <option value="#ffaa00">Orange</option>
              <option value="#ffff00">Jaune</option>
              <option value="#aa00ff">Violet</option>
              <option value="#00ffff">Cyan</option>
              <option value="#ff00aa">Magenta</option>
              <option value="#ffffff">Blanc</option>
            </select>
          </label>
          <label>
            <span>Texte dans la case :</span>
            <input type="text" id="cellText" placeholder="Ex : TO, Appui 1...">
          </label>
          <label>
            <span>Couleur du texte :</span>
            <select id="textColor">
              <option value="">(M√™me que bordure)</option>
              <option value="#000000">Noir</option>
              <option value="#ff0000">Rouge</option>
              <option value="#0000ff">Bleu</option>
              <option value="#00aa00">Vert</option>
              <option value="#ffaa00">Orange</option>
              <option value="#ffff00">Jaune</option>
              <option value="#aa00ff">Violet</option>
              <option value="#00ffff">Cyan</option>
              <option value="#ff00aa">Magenta</option>
              <option value="#ffffff">Blanc</option>
            </select>
          </label>

          <small style="font-size:11px;color:var(--text-sub); white-space:normal;">
            Clique sur une case pour appliquer l'action choisie.<br>
            Si un texte est d√©fini, croix et codes sont d√©sactiv√©s pour cette case.<br>
            Utilise ‚Ü© / ‚Ü™ pour revenir en arri√®re ou en avant sur tes modifs.
          </small>
        </div>
      </div>
    </div>
  </div>

  <!-- Overlay AIDE (d√©marre ouvert via JS) -->
  <div id="helpOverlay" class="help-overlay hidden">
    <div class="help-modal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <button id="closeHelpBtn" class="help-close" aria-label="Fermer l'aide">‚úï</button>
      <h2 id="helpTitle">Guide rapide QuadRico</h2>

      <h3>1. Charger une image ou une grille seule</h3>
      <ul>
        <li><strong>Source &gt; Image</strong> : importe une photo (satellite, plan, etc.).</li>
        <li><strong>Grille sans image</strong> : cr√©e un quadrillage seul (fond noir) sans image de base.</li>
      </ul>

      <h3>2. Cr√©er le quadrillage</h3>
      <ul>
        <li>R√©gle <strong>Colonnes / Lignes</strong> selon tes besoins (ex : 10√ó14).</li>
        <li>Choisis le <strong>type de quadrillage</strong> : Noir, Rouge ou FSI (4 couleurs).</li>
        <li>Choisis le <strong>type de code</strong> : aucun, noir, rouge ou FSI (A1, B3...).</li>
        <li>Clique sur <strong>APPLIQUER</strong> pour afficher / mettre √† jour la grille.</li>
      </ul>

      <h3>3. Travail par case</h3>
      <ul>
        <li>Active <strong>S√©lection de case</strong> pour modifier une case pr√©cise.</li>
        <li>Choisis l'action :
          <ul>
            <li><em>Appliquer</em> : bordure, couleur, texte personnalis√©.</li>
            <li><em>Effacer bordure</em> : supprime le trait sur cette case.</li>
            <li><em>Effacer texte/croix</em> : supprime codes, croix, texte.</li>
            <li><em>Fusionner</em> : regroupe plusieurs cases en une seule zone.</li>
            <li><em>Fractionner</em> : retire une case d'une zone fusionn√©e.</li>
          </ul>
        </li>
      </ul>

      <h3>4. Sauvegarde et partage</h3>
      <ul>
        <li><strong>üíæ Sauvegarder sc√©nario</strong> : t√©l√©charge un fichier <code>.json</code> contenant toute ta configuration (grille, fusions, textes...).</li>
        <li><strong>üìÇ Charger sc√©nario</strong> : recharge un fichier <code>.json</code> QuadRico pour retrouver un dispositif d√©j√† pr√©par√©.</li>
      </ul>

      <h3>5. Export & briefing</h3>
      <ul>
        <li><strong>üñ® A4 / A3</strong> : impression/PDF en portrait ou paysage (selon l'ic√¥ne orientation).</li>
        <li><strong>‚¨á</strong> : t√©l√©charge la carte en image PNG.</li>
        <li><strong>üé¨</strong> : mode briefing pour afficher la carte en grand (projection salle).</li>
      </ul>
    </div>
  </div>

  <footer>
    QuadRico ‚Äì Outil libre d'utilisation, non contractuel.  
    G√©n√©rateur de quadrillage mis √† disposition √† titre gratuit pour un usage p√©dagogique.
  </footer>

  <!-- Input cach√© pour charger un sc√©nario JSON -->
  <input type="file" id="scenarioFileInput" accept="application/json" style="display:none;">

  <script>
    const imageLoader   = document.getElementById('imageLoader');
    const canvas        = document.getElementById('canvas');
    const ctx           = canvas.getContext('2d');
    const drawBtn       = document.getElementById('drawBtn');
    const undoDeleteBtn = document.getElementById('undoDeleteBtn');
    const downloadBtn   = document.getElementById('downloadBtn');
    const printBtn      = document.getElementById('printBtn');
    const printA3Btn    = document.getElementById('printA3Btn');
    const resetBtn      = document.getElementById('resetBtn');
    const msg           = document.getElementById('msg');

    const undoBtn       = document.getElementById('undoBtn');
    const redoBtn       = document.getElementById('redoBtn');

    const contactInfo   = document.getElementById('contactInfo');
    const iconHint      = document.getElementById('iconHint');

    const dashedLines   = document.getElementById('dashedLines');
    const crossBlack    = document.getElementById('crossBlack');
    const crossRed      = document.getElementById('crossRed');
    const crossFSI      = document.getElementById('crossFSI');

    const gridOnly      = document.getElementById('gridOnly');
    const imageOpacity  = document.getElementById('imageOpacity');
    const gridOpacity   = document.getElementById('gridOpacity');
    const codeOpacity   = document.getElementById('codeOpacity');

    const zoomRange     = document.getElementById('zoomRange');
    const zoomValue     = document.getElementById('zoomValue');
    const zoomNumber    = document.getElementById('zoomNumber');

    const selectionMode = document.getElementById('selectionMode');
    const borderColorEl = document.getElementById('borderColor');
    const textColorEl   = document.getElementById('textColor');
    const cellTextEl    = document.getElementById('cellText');

    const themeToggle   = document.getElementById('themeToggle');
    const orientationToggle = document.getElementById('orientationToggle');
    const fullscreenToggle  = document.getElementById('fullscreenToggle');
    const briefingBtn   = document.getElementById('briefingBtn');
    const contactBtn    = document.getElementById('contactBtn');
    const optionsToggle = document.getElementById('optionsToggle');
    const root          = document.documentElement;

    const modeApplyBtn       = document.getElementById('modeApply');
    const modeEraseBorderBtn = document.getElementById('modeEraseBorder');
    const modeEraseCodeBtn   = document.getElementById('modeEraseCode');
    const modeMergeBtn       = document.getElementById('modeMerge');
    const modeSplitBtn       = document.getElementById('modeSplit');
    const autoRefresh        = document.getElementById('autoRefresh');

    const saveScenarioBtn    = document.getElementById('saveScenarioBtn');
    const loadScenarioBtn    = document.getElementById('loadScenarioBtn');
    const scenarioFileInput  = document.getElementById('scenarioFileInput');

    const helpBtn            = document.getElementById('helpBtn');
    const helpOverlay        = document.getElementById('helpOverlay');
    const closeHelpBtn       = document.getElementById('closeHelpBtn');

    let selectionAction = "apply";

    let img = null;

    const MARGIN_LEFT = 40;
    const MARGIN_TOP  = 40;

    let selectedCells = {};
    let lastGridGeom  = null;

    let mergedRegions = [];
    let nextRegionId = 1;
    let currentRegionId = null;

    let history = [];
    let historyIndex = -1;

    let orientationMode = "portrait";
    let printOrientation = "portrait";

    let briefingMode = false;

    let baseCanvasWidth = 0;
    let baseCanvasHeight = 0;

    function setMsg(text) {
      msg.textContent = text || "";
    }

    function handleCrossChange(changed) {
      if (changed.checked) {
        if (changed !== crossBlack) crossBlack.checked = false;
        if (changed !== crossRed)   crossRed.checked   = false;
        if (changed !== crossFSI)   crossFSI.checked   = false;
      }
    }

    crossBlack.addEventListener('change', () => { handleCrossChange(crossBlack); autoRedrawIfEnabled(); });
    crossRed.addEventListener('change',   () => { handleCrossChange(crossRed);   autoRedrawIfEnabled(); });
    crossFSI.addEventListener('change',   () => { handleCrossChange(crossFSI);   autoRedrawIfEnabled(); });

    function getLegendMode() {
      const r = document.querySelector('input[name="legendMode"]:checked');
      return r ? r.value : "full";
    }

    function updateThemeButton() {
      const current = root.getAttribute('data-theme') || 'dark';
      const iconSpan = themeToggle.querySelector('.theme-toggle-icon');
      iconSpan.textContent = current === 'dark' ? '‚òØ' : '‚òº';
    }

    themeToggle.addEventListener('click', () => {
      const current = root.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      root.setAttribute('data-theme', next);
      updateThemeButton();
    });

    updateThemeButton();

    function updateOrientationButton() {
      if (orientationMode === "portrait") {
        orientationToggle.textContent = "üñºÔ∏è‚Üï";
        orientationToggle.title = "Mode portrait (affichage et impression)";
      } else {
        orientationToggle.textContent = "üñºÔ∏è‚Üî";
        orientationToggle.title = "Mode paysage (affichage et impression)";
      }
      printOrientation = orientationMode;
    }

    orientationToggle.addEventListener('click', () => {
      orientationMode = (orientationMode === "portrait") ? "landscape" : "portrait";
      updateOrientationButton();
      if (img || gridOnly.checked) {
        drawGrid();
      } else {
        setMsg("Choisis une image ou active \"Grille sans image\" puis clique sur APPLIQUER.");
      }
    });

    updateOrientationButton();

    fullscreenToggle.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      } else {
        document.exitFullscreen().catch(() => {});
      }
    });

    function setIconHint(text) {
      iconHint.textContent = text || "";
    }

    function addIconHint(btn, text) {
      if (!btn) return;
      btn.addEventListener('mouseenter', () => setIconHint(text));
      btn.addEventListener('mouseleave', () => setIconHint(""));
    }

    addIconHint(themeToggle,      "Basculer entre mode sombre et mode clair");
    addIconHint(orientationToggle,"Basculer entre portrait et paysage (affichage & impression)");
    addIconHint(fullscreenToggle, "Basculer en mode plein √©cran");
    addIconHint(briefingBtn,      "Mode briefing : la carte est mise en avant, les r√©glages sont masqu√©s.");
    addIconHint(saveScenarioBtn,  "Sauvegarder le sc√©nario (fichier JSON)");
    addIconHint(loadScenarioBtn,  "Charger un sc√©nario QuadRico (.json)");
    addIconHint(helpBtn,          "Afficher le guide rapide QuadRico");
    addIconHint(printBtn,         "Imprimer / exporter en PDF A4");
    addIconHint(printA3Btn,       "Imprimer / exporter en PDF A3");
    addIconHint(downloadBtn,      "T√©l√©charger l'image quadrill√©e en PNG");
    addIconHint(resetBtn,         "R√©initialiser tous les r√©glages et effacer la grille");
    addIconHint(contactBtn,       "Envoyer un mail au concepteur de QuadRico");
    addIconHint(optionsToggle,    "Afficher / masquer le bloc options (mode mobile)");

    contactBtn.addEventListener('click', () => {
      contactInfo.textContent =
        "Pour toutes questions, remarques ou demandes d'am√©lioration, contacter par mail : eric.marchetti@gendarmerie.interieur.gouv.fr";
      window.location.href = "mailto:eric.marchetti@gendarmerie.interieur.gouv.fr";
    });

    briefingBtn.addEventListener('click', () => {
      briefingMode = !briefingMode;
      document.body.classList.toggle('briefing-mode', briefingMode);

      if (briefingMode && baseCanvasWidth && baseCanvasHeight) {
        const availW = window.innerWidth - 40;
        const availH = window.innerHeight - 160;
        let scale = Math.min(availW / baseCanvasWidth, availH / baseCanvasHeight);
        scale = Math.max(0.5, Math.min(scale, 3));
        zoomRange.value = Math.round(scale * 100);
        zoomNumber.value = zoomRange.value;
        applyZoomScale();
        setIconHint("Mode briefing : vue g√©n√©rale de la carte.");
      } else {
        zoomRange.value = 100;
        zoomNumber.value = 100;
        applyZoomScale();
        setIconHint("Mode normal : r√©glages r√©affich√©s.");
      }
    });

    optionsToggle.addEventListener('click', () => {
      document.body.classList.toggle('options-collapsed');
    });

    function initOptionsCollapsedOnLoad() {
      if (window.innerWidth <= 900) {
        document.body.classList.add('options-collapsed');
      } else {
        document.body.classList.remove('options-collapsed');
      }
    }

    window.addEventListener('resize', () => {
      if (window.innerWidth > 900) {
        document.body.classList.remove('options-collapsed');
      }
    });

    initOptionsCollapsedOnLoad();

    imageLoader.addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) {
        setMsg("Aucun fichier s√©lectionn√©.");
        return;
      }

      const reader = new FileReader();
      reader.onload = function (ev) {
        const image = new Image();
        image.onload = function () {
          img = image;
          gridOnly.checked = false;
          setMsg("Image charg√©e. Clique sur \"APPLIQUER\".");
          drawBase();
          downloadBtn.disabled = true;
          if (autoRefresh.checked) {
            drawGrid();
          }
        };
        image.onerror = function () {
          setMsg("Erreur lors du chargement de l'image.");
        };
        image.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    function getGridType() {
      const r = document.querySelector('input[name="gridType"]:checked');
      return r ? r.value : "fsi";
    }

    function getLabelMode() {
      const r = document.querySelector('input[name="labelMode"]:checked');
      return r ? r.value : "none";
    }

    function getCrossMode() {
      if (crossBlack.checked) return "black";
      if (crossRed.checked)   return "red";
      if (crossFSI.checked)   return "fsi";
      return "none";
    }

    function getBorderWidthPx() {
      const r = document.querySelector('input[name="borderWidth"]:checked');
      const v = r ? r.value : "normal";
      if (v === "epais") return 4;
      if (v === "tres-epais") return 6;
      return 2;
    }

    function applyZoomScale() {
      if (!baseCanvasWidth || !baseCanvasHeight) return;
      const zoom = parseInt(zoomRange.value, 10);
      const scale = zoom / 100;
      const scrollContainer = document.querySelector('.canvas-scroll');
      const isMobile = window.innerWidth < 900;

      zoomValue.textContent = zoom + "%";
      if (zoomNumber) zoomNumber.value = zoom;

      if (isMobile && zoom <= 100) {
        canvas.style.width  = "";
        canvas.style.height = "";
      } else {
        canvas.style.width  = (baseCanvasWidth * scale) + "px";
        canvas.style.height = (baseCanvasHeight * scale) + "px";
      }

      if (scrollContainer) {
        if (zoom >= 113) {
          scrollContainer.style.maxHeight = '80vh';
          scrollContainer.style.overflow = 'auto';
        } else {
          scrollContainer.style.maxHeight = '';
          scrollContainer.style.overflow = 'visible';
        }
      }
    }

    let imgSizeCache = null;

    function drawBase() {
      const cols = parseInt(document.getElementById('cols').value, 10) || 10;
      const rows = parseInt(document.getElementById('rows').value, 10) || 10;
      const useGridOnly = gridOnly.checked;

      let imgW, imgH;

      if (useGridOnly || !img) {
        const cellSize = 40;
        if (orientationMode === "portrait") {
          imgW = cols * cellSize;
          imgH = rows * cellSize;
        } else {
          imgW = rows * cellSize;
          imgH = cols * cellSize;
        }
      } else {
        if (orientationMode === "portrait") {
          imgW = img.width;
          imgH = img.height;
        } else {
          imgW = img.height;
          imgH = img.width;
        }
      }

      canvas.width  = imgW + 2 * MARGIN_LEFT;
      canvas.height = imgH + 2 * MARGIN_TOP;

      baseCanvasWidth = canvas.width;
      baseCanvasHeight = canvas.height;
      applyZoomScale();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!useGridOnly) {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      const imgAlpha = parseInt(imageOpacity.value, 10) / 100;

      if (!useGridOnly && img) {
        ctx.save();
        ctx.globalAlpha = imgAlpha;

        if (orientationMode === "portrait") {
          ctx.drawImage(img, MARGIN_LEFT, MARGIN_TOP);
        } else {
          ctx.translate(MARGIN_LEFT, MARGIN_TOP + imgH);
          ctx.rotate(-Math.PI / 2);
          ctx.drawImage(img, 0, 0);
        }

        ctx.restore();
      }

      const cellW = imgW / cols;
      const cellH = imgH / rows;
      lastGridGeom = { cols, rows, cellW, cellH, imgW, imgH };
      imgSizeCache = { imgW, imgH };
    }

    function findRegionByCell(c, r) {
      for (const region of mergedRegions) {
        if (region.cells.some(cell => cell.c === c && cell.r === r)) {
          return region;
        }
      }
      return null;
    }

    function drawGrid() {
      const cols = parseInt(document.getElementById('cols').value, 10);
      const rows = parseInt(document.getElementById('rows').value, 10);

      if (!cols || !rows || cols < 1 || rows < 1) {
        setMsg("Colonnes / lignes invalides.");
        return;
      }

      const gridType    = getGridType();
      const labelMode   = getLabelMode();
      const useDashed   = dashedLines.checked;
      const crossMode   = getCrossMode();
      const useGridOnly = gridOnly.checked;
      const legendMode  = getLegendMode();

      if (!useGridOnly && !img) {
        setMsg("Charge d'abord une image ou active \"Grille sans image\".");
        return;
      }

      drawBase();
      if (!lastGridGeom) return;

      const { cellW, cellH, imgW, imgH, cols: C, rows: R } = lastGridGeom;

      const midCol = C / 2;
      const midRow = R / 2;

      const colorTL = 'yellow';
      const colorTR = 'blue';
      const colorBR = 'green';
      const colorBL = 'red';

      const gridAlpha = parseInt(gridOpacity.value, 10) / 100;
      const codeAlpha = parseInt(codeOpacity.value, 10) / 100;

      function isNoGridCell(c, r) {
        const key = `${c},${r}`;
        const sel = selectedCells[key];
        return sel && sel.noGrid;
      }

      function edgeSuppressedVertical(c, r) {
        const leftNo  = (c - 1 >= 0) ? isNoGridCell(c - 1, r) : false;
        const rightNo = (c < C)      ? isNoGridCell(c, r)     : false;
        if (leftNo || rightNo) return true;

        if (c - 1 >= 0 && c < C) {
          const regL = findRegionByCell(c - 1, r);
          const regR = findRegionByCell(c, r);
          if (regL && regR && regL.id === regR.id) return true;
        }
        return false;
      }

      function edgeSuppressedHorizontal(c, r) {
        const topNo    = (r - 1 >= 0) ? isNoGridCell(c, r - 1) : false;
        const bottomNo = (r < R)      ? isNoGridCell(c, r)     : false;
        if (topNo || bottomNo) return true;

        if (r - 1 >= 0 && r < R) {
          const regT = findRegionByCell(c, r - 1);
          const regB = findRegionByCell(c, r);
          if (regT && regB && regT.id === regB.id) return true;
        }
        return false;
      }

      ctx.lineWidth = 1.5;

      if (useDashed && gridType !== "none") {
        ctx.setLineDash([20, 10]);
      } else {
        ctx.setLineDash([]);
      }

      if (gridType !== "none") {
        ctx.save();
        ctx.globalAlpha = gridAlpha;

        for (let c = 0; c <= C; c++) {
          const x = MARGIN_LEFT + c * cellW;
          for (let r = 0; r < R; r++) {
            if (edgeSuppressedVertical(c, r)) continue;

            const y1 = MARGIN_TOP + r * cellH;
            const y2 = MARGIN_TOP + (r + 1) * cellH;

            const colIndex = Math.min(c === C ? c - 1 : c, C - 1);
            const color = (gridType === "fsi")
              ? ((colIndex < midCol && r < midRow)       ? colorTL
                : (colIndex >= midCol && r < midRow)     ? colorTR
                : (colIndex >= midCol && r >= midRow)    ? colorBR
                :                                          colorBL)
              : (gridType === "uni-red" ? "red"
                : gridType === "uni-black" ? "black"
                : "black");

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }
        }

        for (let r = 0; r <= R; r++) {
          const y = MARGIN_TOP + r * cellH;
          for (let c = 0; c < C; c++) {
            if (edgeSuppressedHorizontal(c, r)) continue;

            const x1 = MARGIN_LEFT + c * cellW;
            const x2 = MARGIN_LEFT + (c + 1) * cellW;

            const rowIndex = Math.min(r === R ? r - 1 : r, R - 1);
            const color = (gridType === "fsi")
              ? ((c < midCol && rowIndex < midRow)       ? colorTL
                : (c >= midCol && rowIndex < midRow)     ? colorTR
                : (c >= midCol && rowIndex >= midRow)    ? colorBR
                :                                          colorBL)
              : (gridType === "uni-red" ? "red"
                : gridType === "uni-black" ? "black"
                : "black");

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.stroke();
          }
        }

        ctx.restore();
      }

      if (legendMode !== "none") {
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.fillStyle = useGridOnly ? "#ffffff" : "black";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        if (legendMode === "partial" || legendMode === "full") {
          for (let c = 0; c < C; c++) {
            const label = String.fromCharCode(65 + c);
            ctx.fillText(label, MARGIN_LEFT + (c + 0.5) * cellW, MARGIN_TOP / 2);
          }

          ctx.textAlign = "right";
          for (let r = 0; r < R; r++) {
            ctx.fillText((r + 1), MARGIN_LEFT - 5, MARGIN_TOP + (r + 0.5) * cellH);
          }
        }

        if (legendMode === "full") {
          ctx.textAlign = "center";
          const bottomY = MARGIN_TOP + imgH + MARGIN_TOP / 2;
          for (let c = 0; c < C; c++) {
            const label = String.fromCharCode(65 + c);
            ctx.fillText(label, MARGIN_LEFT + (c + 0.5) * cellW, bottomY);
          }

          ctx.textAlign = "left";
          const rightX = MARGIN_LEFT + imgW + 5;
          for (let r = 0; r < R; r++) {
            ctx.fillText((r + 1), rightX, MARGIN_TOP + (r + 0.5) * cellH);
          }
        }
      }

      if (crossMode !== "none") {
        ctx.lineWidth = 1.2;
        ctx.setLineDash([]);
        ctx.globalAlpha = codeAlpha;

        for (let r = 0; r < R; r++) {
          for (let c = 0; c < C; c++) {
            const key = `${c},${r}`;
            const sel = selectedCells[key];
            if (sel && ((sel.text && sel.text.length > 0) || sel.noCode)) continue;

            const regionHere = findRegionByCell(c, r);
            if (regionHere && regionHere.text && regionHere.text.length > 0) continue;

            let color = "black";
            if (crossMode === "black") {
              color = "black";
            } else if (crossMode === "red") {
              color = "red";
            } else if (crossMode === "fsi") {
              if (c < midCol && r < midRow)       color = colorTL;
              else if (c >= midCol && r < midRow) color = colorTR;
              else if (c >= midCol && r >= midRow)color = colorBR;
              else                                color = colorBL;
            }

            ctx.strokeStyle = color;
            const x = MARGIN_LEFT + (c + 0.5) * cellW;
            const y = MARGIN_TOP  + (r + 0.5) * cellH;
            const s = Math.max(3, Math.min(cellW, cellH) * 0.15);

            ctx.beginPath();
            ctx.moveTo(x - s, y - s);
            ctx.lineTo(x + s, y + s);
            ctx.moveTo(x - s, y + s);
            ctx.lineTo(x + s, y - s);
            ctx.stroke();
          }
        }
      }

      if (labelMode !== "none") {
        ctx.setLineDash([]);
        ctx.globalAlpha = codeAlpha;

        const midColLabel = C / 2;
        const midRowLabel = R / 2;

        for (let r = 0; r < R; r++) {
          for (let c = 0; c < C; c++) {
            const key = `${c},${r}`;
            const sel = selectedCells[key];
            if (sel && ((sel.text && sel.text.length > 0) || sel.noCode)) continue;

            const regionHere = findRegionByCell(c, r);
            if (regionHere && regionHere.text && regionHere.text.length > 0) continue;

            const label = String.fromCharCode(65 + c) + (r + 1);
            let textColor = "black";

            if (labelMode === "color") {
              textColor = "red";
            } else if (labelMode === "fsi-color") {
              if (c < midColLabel && r < midRowLabel)       textColor = colorTL;
              else if (c >= midColLabel && r < midRowLabel) textColor = colorTR;
              else if (c >= midColLabel && r >= midRowLabel)textColor = colorBR;
              else                                          textColor = colorBL;
            } else if (labelMode === "uni") {
              textColor = "black";
            }

            ctx.fillStyle = textColor;

            const x = MARGIN_LEFT + (c + 0.5) * cellW;
            const y = MARGIN_TOP  + (r + 0.5) * cellH;
            const padding = Math.min(cellW, cellH) * 0.1;
            const maxWidth = cellW - 2 * padding;
            const maxHeight = cellH - 2 * padding;
            let fontSize = cellH * 0.45;
            if (fontSize < 6) fontSize = 6;

            ctx.font = fontSize + "px sans-serif";
            let metrics = ctx.measureText(label);
            while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
              fontSize -= 1;
              ctx.font = fontSize + "px sans-serif";
              metrics = ctx.measureText(label);
            }

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(label, x, y);
          }
        }
      }

      ctx.setLineDash([]);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (const key in selectedCells) {
        const [cStr, rStr] = key.split(",");
        const c = parseInt(cStr, 10);
        const r = parseInt(rStr, 10);
        if (isNaN(c) || isNaN(r)) continue;
        if (!lastGridGeom) continue;
        const { cols: C2, rows: R2, cellW, cellH } = lastGridGeom;
        if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;

        const regionHere = findRegionByCell(c, r);
        if (regionHere) continue;

        const sel = selectedCells[key];
        const { borderColor, borderWidth, text, textColor, alpha } = sel;

        const xCell = MARGIN_LEFT + c * cellW;
        const yCell = MARGIN_TOP  + r * cellH;
        const a = typeof alpha === "number" ? alpha : 1.0;
        ctx.globalAlpha = a;

        if (borderWidth && borderColor && !sel.noGrid) {
          ctx.lineWidth = borderWidth;
          ctx.strokeStyle = borderColor;
          ctx.strokeRect(xCell, yCell, cellW, cellH);
        }

        if (text && text.length > 0) {
          const drawColor = textColor || borderColor || "#000000";
          ctx.fillStyle = drawColor;

          let fontSize = cellH * 0.45;
          if (fontSize < 6) fontSize = 6;
          ctx.font = fontSize + "px sans-serif";

          const padding = Math.min(cellW, cellH) * 0.1;
          const maxWidth = cellW - 2 * padding;
          const maxHeight = cellH - 2 * padding;
          let metrics = ctx.measureText(text);

          while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
            fontSize -= 1;
            ctx.font = fontSize + "px sans-serif";
            metrics = ctx.measureText(text);
          }

          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            text,
            MARGIN_LEFT + (c + 0.5) * cellW,
            MARGIN_TOP  + (r + 0.5) * cellH
          );
        }
      }

      ctx.globalAlpha = 1;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      function regionHasCell(region, c, r) {
        return region.cells.some(cell => cell.c === c && cell.r === r);
      }

      for (const region of mergedRegions) {
        if (!region.cells || !region.cells.length) continue;
        const { cols: C2, rows: R2, cellW, cellH } = lastGridGeom;

        let minC = Infinity, maxC = -1, minR = Infinity, maxR = -1;
        for (const cell of region.cells) {
          const c = cell.c;
          const r = cell.r;
          if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;
          if (c < minC) minC = c;
          if (c > maxC) maxC = c;
          if (r < minR) minR = r;
          if (r > maxR) maxR = r;
        }
        if (minC === Infinity || minR === Infinity) continue;

        const x = MARGIN_LEFT + minC * cellW;
        const y = MARGIN_TOP  + minR * cellH;
        const w = (maxC - minC + 1) * cellW;
        const h = (maxR - minR + 1) * cellH;

        const alpha = typeof region.alpha === "number" ? region.alpha : 1.0;

        if (region.borderColor && region.borderWidth) {
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.lineWidth = region.borderWidth;
          ctx.strokeStyle = region.borderColor;
          ctx.setLineDash([]);

          for (const cell of region.cells) {
            const c = cell.c;
            const r = cell.r;
            if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;

            const x0 = MARGIN_LEFT + c * cellW;
            const y0 = MARGIN_TOP  + r * cellH;
            const x1 = x0 + cellW;
            const y1 = y0 + cellH;

            if (!regionHasCell(region, c, r - 1)) {
              ctx.beginPath();
              ctx.moveTo(x0, y0);
              ctx.lineTo(x1, y0);
              ctx.stroke();
            }
            if (!regionHasCell(region, c, r + 1)) {
              ctx.beginPath();
              ctx.moveTo(x0, y1);
              ctx.lineTo(x1, y1);
              ctx.stroke();
            }
            if (!regionHasCell(region, c - 1, r)) {
              ctx.beginPath();
              ctx.moveTo(x0, y0);
              ctx.lineTo(x0, y1);
              ctx.stroke();
            }
            if (!regionHasCell(region, c + 1, r)) {
              ctx.beginPath();
              ctx.moveTo(x1, y0);
              ctx.lineTo(x1, y1);
              ctx.stroke();
            }
          }

          ctx.restore();
        }

        if (region.text && region.text.length > 0) {
          const txtColor = region.textColor || region.borderColor || "#ffffff";

          ctx.save();
          ctx.globalAlpha = alpha;

          ctx.beginPath();
          for (const cell of region.cells) {
            const cx = MARGIN_LEFT + cell.c * cellW;
            const cy = MARGIN_TOP  + cell.r * cellH;
            ctx.rect(cx, cy, cellW, cellH);
          }
          ctx.clip();

          const padding = Math.min(w, h) * 0.1;
          const maxWidth = w - 2 * padding;
          const maxHeight = h - 2 * padding;
          let fontSize = h * 0.45;
          if (fontSize < 6) fontSize = 6;

          ctx.font = fontSize + "px sans-serif";
          let metrics = ctx.measureText(region.text);

          while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
            fontSize -= 1;
            ctx.font = fontSize + "px sans-serif";
            metrics = ctx.measureText(region.text);
          }

          ctx.fillStyle = txtColor;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const centerX = x + w / 2;
          const centerY = y + h / 2;
          ctx.fillText(region.text, centerX, centerY);

          ctx.restore();
        }
      }

      ctx.globalAlpha = 1;
      downloadBtn.disabled = false;
      setMsg("Quadrillage appliqu√©. Tu peux t√©l√©charger ou imprimer l'image.");
    }

    drawBtn.addEventListener('click', drawGrid);

    function setSelectionAction(action) {
      selectionAction = action;
      [modeApplyBtn, modeEraseBorderBtn, modeEraseCodeBtn, modeMergeBtn, modeSplitBtn]
        .forEach(btn => btn.classList.remove('active'));
      if (action === "apply") modeApplyBtn.classList.add('active');
      if (action === "eraseBorder") modeEraseBorderBtn.classList.add('active');
      if (action === "eraseCode") modeEraseCodeBtn.classList.add('active');
      if (action === "merge") modeMergeBtn.classList.add('active');
      if (action === "split") modeSplitBtn.classList.add('active');
    }

    modeApplyBtn.addEventListener('click', () => setSelectionAction("apply"));
    modeEraseBorderBtn.addEventListener('click', () => setSelectionAction("eraseBorder"));
    modeEraseCodeBtn.addEventListener('click', () => setSelectionAction("eraseCode"));
    modeMergeBtn.addEventListener('click', () => setSelectionAction("merge"));
    modeSplitBtn.addEventListener('click', () => setSelectionAction("split"));

    function pushHistory() {
      const snapshot = structuredClone({
        selectedCells,
        mergedRegions,
        currentRegionId
      });
      history = history.slice(0, historyIndex + 1);
      history.push(snapshot);
      historyIndex = history.length - 1;
    }

    function restoreFromHistory() {
      if (historyIndex < 0 || historyIndex >= history.length) return;
      const snap = history[historyIndex];
      selectedCells = structuredClone(snap.selectedCells);
      mergedRegions  = structuredClone(snap.mergedRegions);
      currentRegionId = snap.currentRegionId;
      drawGrid();
    }

    undoBtn.addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        restoreFromHistory();
        setMsg("Retour en arri√®re.");
      } else {
        setMsg("Aucune action √† annuler.");
      }
    });

    redoBtn.addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreFromHistory();
        setMsg("Aucune action √† r√©tablir.");
      } else {
        setMsg("Aucune action √† r√©tablir.");
      }
    });

    canvas.addEventListener('click', (e) => {
      if (!selectionMode.checked) return;
      if (!lastGridGeom) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;

      const { cols, rows, cellW, cellH, imgW, imgH } = lastGridGeom;

      if (x < MARGIN_LEFT || x > MARGIN_LEFT + imgW ||
          y < MARGIN_TOP  || y > MARGIN_TOP  + imgH) {
        return;
      }

      const c = Math.floor((x - MARGIN_LEFT) / cellW);
      const r = Math.floor((y - MARGIN_TOP)  / cellH);
      if (c < 0 || c >= cols || r < 0 || r >= rows) return;

      const key = `${c},${r}`;
      let regionHere = findRegionByCell(c, r);

      if (selectionAction === "merge" && regionHere) {
        currentRegionId = regionHere.id;
      }

      pushHistory();

      if (selectionAction === "apply") {
        const borderColor = borderColorEl.value;
        const borderWidth = getBorderWidthPx();
        const text = cellTextEl.value.trim();
        const txtColor = textColorEl.value || "";
        const alpha = 1.0;

        if (regionHere) {
          regionHere.borderColor = borderColor;
          regionHere.borderWidth = borderWidth;
          regionHere.text       = text;
          regionHere.textColor  = txtColor;
          regionHere.alpha      = alpha;
        } else {
          selectedCells[key] = {
            borderColor,
            borderWidth,
            text,
            textColor: txtColor,
            noCode: text.length > 0,
            noGrid: selectedCells[key]?.noGrid || false,
            alpha
          };
        }
      } else if (selectionAction === "eraseBorder") {
        if (regionHere) {
          for (const cell of regionHere.cells) {
            const k = `${cell.c},${cell.r}`;
            const cSel = selectedCells[k] || {};
            delete cSel.borderColor;
            delete cSel.borderWidth;
            cSel.noGrid = true;
            selectedCells[k] = cSel;
          }
          regionHere.borderColor = null;
          regionHere.borderWidth = null;
        } else {
          const cell = selectedCells[key] || {};
          delete cell.borderColor;
          delete cell.borderWidth;
          cell.noGrid = true;
          selectedCells[key] = cell;
        }
      } else if (selectionAction === "eraseCode") {
        if (regionHere) {
          for (const cell of regionHere.cells) {
            const k = `${cell.c},${cell.r}`;
            const cSel = selectedCells[k] || {};
            cSel.noCode = true;
            cSel.text   = "";
            selectedCells[k] = cSel;
          }
          regionHere.text = "";
        } else {
          const cell = selectedCells[key] || {};
          cell.noCode = true;
          cell.text = "";
          selectedCells[key] = cell;
        }
      } else if (selectionAction === "merge") {
        let region = regionHere;
        if (!region) {
          if (currentRegionId) {
            region = mergedRegions.find(rg => rg.id === currentRegionId);
            if (!region) {
              region = { id: nextRegionId++, cells: [], borderColor: null, borderWidth: null, text: "", textColor: "", alpha: 1 };
              mergedRegions.push(region);
              currentRegionId = region.id;
            }
          } else {
            region = { id: nextRegionId++, cells: [], borderColor: null, borderWidth: null, text: "", textColor: "", alpha: 1 };
            mergedRegions.push(region);
            currentRegionId = region.id;
          }
        } else {
          currentRegionId = region.id;
        }

        if (!region.cells.some(cell => cell.c === c && cell.r === r)) {
          region.cells.push({ c, r });
        }
      } else if (selectionAction === "split") {
        if (regionHere) {
          regionHere.cells = regionHere.cells.filter(cell => !(cell.c === c && cell.r === r));

          if (regionHere.cells.length === 0) {
            const regionIndex = mergedRegions.findIndex(rg => rg.id === regionHere.id);
            if (regionIndex >= 0) {
              mergedRegions.splice(regionIndex, 1);
            }
            if (currentRegionId === regionHere.id) {
              currentRegionId = null;
            }
          }
        } else {
          setMsg("Cette case n'est pas fusionn√©e, rien √† fractionner ici.");
        }
      }

      drawGrid();
    });

    undoDeleteBtn.addEventListener('click', () => {
      if (!lastGridGeom) {
        setMsg("Aucune grille appliqu√©e pour supprimer les modifications.");
        return;
      }
      selectedCells = {};
      mergedRegions = [];
      currentRegionId = null;
      nextRegionId = 1;
      pushHistory();
      drawGrid();
      setMsg("Toutes les modifications (bordures, textes, fusions) ont √©t√© supprim√©es.");
    });

    downloadBtn.addEventListener('click', function () {
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† t√©l√©charger : applique un quadrillage d'abord.");
        return;
      }
      const link = document.createElement('a');
      link.href = canvas.toDataURL("image/png");
      link.download = "image_quadrillage.png";
      link.click();
    });

    function printWithSize(pageSize) {
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† imprimer : applique un quadrillage d'abord.");
        return;
      }

      const dataUrl = canvas.toDataURL("image/png");
      const printWindow = window.open("", "_blank");
      if (!printWindow) {
        setMsg("Impossible d'ouvrir la fen√™tre d'impression (popup bloqu√©e ?).");
        return;
      }

      printWindow.document.write(`
        <html>
          <head>
            <title>QuadRico - Impression</title>
            <style>
              @page { size: ${pageSize} ${printOrientation}; margin: 10mm; }
              body {
                margin: 0;
                padding: 0;
                text-align: center;
              }
              img {
                max-width: 100%;
                max-height: 95vh;
                width: auto;
                height: auto;
              }
            </style>
          </head>
          <body>
            <img src="${dataUrl}" />
            <script>
              window.onload = function() {
                window.focus();
                window.print();
              };
            <\/script>
          </body>
        </html>
      `);
      printWindow.document.close();
    }

    printBtn.addEventListener('click', () => printWithSize("A4"));
    printA3Btn.addEventListener('click', () => printWithSize("A3"));

    resetBtn.addEventListener('click', function () {
      document.getElementById('cols').value = 10;
      document.getElementById('rows').value = 14;

      document.querySelector('input[name="gridType"][value="fsi"]').checked = true;
      document.querySelector('input[name="legendMode"][value="full"]').checked = true;
      document.querySelector('input[name="labelMode"][value="none"]').checked = true;

      dashedLines.checked = false;
      crossBlack.checked  = false;
      crossRed.checked    = false;
      crossFSI.checked    = false;

      gridOnly.checked = false;
      imageOpacity.value = 100;
      gridOpacity.value = 100;
      codeOpacity.value = 100;

      zoomRange.value = 100;
      zoomNumber.value = 100;
      zoomValue.textContent = "100%";
      baseCanvasWidth = 0;
      baseCanvasHeight = 0;
      canvas.style.width  = "";
      canvas.style.height = "";

      selectionMode.checked = false;
      setSelectionAction("apply");
      borderColorEl.value = "#000000";
      textColorEl.value = "";
      cellTextEl.value = "";

      selectedCells = {};
      mergedRegions = [];
      nextRegionId = 1;
      currentRegionId = null;
      history = [];
      historyIndex = -1;

      imageLoader.value = "";
      img = null;
      lastGridGeom = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      downloadBtn.disabled = true;

      orientationMode = "portrait";
      updateOrientationButton();

      briefingMode = false;
      document.body.classList.remove('briefing-mode');

      autoRefresh.checked = false;

      setMsg("R√©initialis√©. Charge une nouvelle image ou active \"Grille sans image\" pour recommencer.");
      initOptionsCollapsedOnLoad();
    });

    zoomRange.addEventListener('input', () => {
      applyZoomScale();
    });

    zoomNumber.addEventListener('change', () => {
      let val = parseInt(zoomNumber.value, 10);
      if (isNaN(val)) val = 100;
      if (val < 50) val = 50;
      if (val > 300) val = 300;
      zoomNumber.value = val;
      zoomRange.value = val;
      applyZoomScale();
    });

    function autoRedrawIfEnabled() {
      if (!autoRefresh.checked) return;
      if (!img && !gridOnly.checked) {
        setMsg("Active \"Grille sans image\" ou charge une image, puis applique.");
        return;
      }
      drawGrid();
    }

    autoRefresh.addEventListener('change', () => {
      if (autoRefresh.checked) {
        if (img || gridOnly.checked) {
          drawGrid();
        } else {
          setMsg("Active \"Grille sans image\" ou charge une image.");
        }
      }
    });

    gridOnly.addEventListener('change', autoRedrawIfEnabled);
    document.getElementById('cols').addEventListener('change', autoRedrawIfEnabled);
    document.getElementById('rows').addEventListener('change', autoRedrawIfEnabled);

    document.querySelectorAll('input[name="legendMode"]').forEach(r => {
      r.addEventListener('change', autoRedrawIfEnabled);
    });

    document.querySelectorAll('input[name="gridType"]').forEach(r => {
      r.addEventListener('change', autoRedrawIfEnabled);
    });

    document.querySelectorAll('input[name="labelMode"]').forEach(r => {
      r.addEventListener('change', autoRedrawIfEnabled);
    });

    imageOpacity.addEventListener('input', autoRedrawIfEnabled);
    gridOpacity.addEventListener('input', autoRedrawIfEnabled);
    codeOpacity.addEventListener('input', autoRedrawIfEnabled);
    dashedLines.addEventListener('change', autoRedrawIfEnabled);

    /* ==== AIDE / MODAL ==== */

    function closeHelp() {
      helpOverlay.classList.add('hidden');
    }

    function openHelp() {
      helpOverlay.classList.remove('hidden');
    }

    helpBtn.addEventListener('click', () => {
      openHelp();
    });

    closeHelpBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeHelp();
    });

    helpOverlay.addEventListener('click', (e) => {
      if (e.target === helpOverlay) {
        closeHelp();
      }
    });

    // Ouvrir automatiquement l'aide au d√©marrage
    openHelp();

  </script>
</body>
</html>
