<!DOCTYPE html>
<html lang="fr" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>QuadRico ‚Äì G√©n√©rateur de quadrillage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* PALETTES TH√àME */
    :root[data-theme="dark"] {
      --bg-main: #080a0f;
      --bg-panel: #151821;
      --border-panel: #2b3140;
      --text-main: #f5f5f7;
      --text-sub: #c3c7d1;
      --accent: #2f81ff;
      --accent-soft: rgba(47,129,255,0.15);
      --danger: #ff4b5c;
      --danger-soft: rgba(255,75,92,0.18);
      --success: #22c55e;
      --success-soft: rgba(34,197,94,0.18);
      --btn-bg: #1e2330;
      --btn-bg-hover: #272d3c;
      --canvas-bg: #000000;
    }

    :root[data-theme="light"] {
      --bg-main: #f4f5f8;
      --bg-panel: #ffffff;
      --border-panel: #d3d7e2;
      --text-main: #111827;
      --text-sub: #4b5563;
      --accent: #2563eb;
      --accent-soft: rgba(37,99,235,0.08);
      --danger: #dc2626;
      --danger-soft: rgba(220,38,38,0.12);
      --success: #16a34a;
      --success-soft: rgba(22,163,74,0.12);
      --btn-bg: #f3f4f6;
      --btn-bg-hover: #e5e7eb;
      --canvas-bg: #ffffff;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: radial-gradient(circle at top left, #141b2b 0, #080a0f 45%, #050609 100%);
      color: var(--text-main);
      transition: background 0.25s ease, color 0.25s ease;
      overflow-x: hidden;
      overflow-y: auto;
    }

    :root[data-theme="light"] body {
      background: #e5e7eb;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      background: #111522;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      overflow: hidden;
      border: 1px solid #28324a;
      box-shadow: 0 0 12px rgba(0,0,0,0.6);
    }

    :root[data-theme="light"] .logo-mark {
      background: #ffffff;
      border-color: #cbd5f5;
      box-shadow: 0 0 8px rgba(148,163,184,0.6);
    }

    .logo-cell { width: 100%; height: 100%; }
    .logo-yellow { background: #ffd54a; }
    .logo-blue   { background: #4aa3ff; }
    .logo-green  { background: #4adf7c; }
    .logo-red    { background: #ff5f5f; }

    .logo-text { display: flex; flex-direction: column; line-height: 1.1; }
    .logo-text-main {
      font-weight: 600;
      font-size: 22px;
      letter-spacing: 0.05em;
    }
    .logo-text-sub {
      font-size: 12px;
      color: var(--text-sub);
    }

    /* BARRE PRINCIPALE (3 LIGNES) */

    .top-bar-main {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin: 10px 0 6px 0;
    }

    .contact-info {
      font-size: 12px;
      color: var(--text-sub);
      text-align: center;
      min-height: 16px;
      white-space: normal;
    }

    .system-icons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .top-icon-btn {
      min-width: auto;
      padding: 10px 14px;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.45);
      line-height: 1;
    }

    :root[data-theme="light"] .top-icon-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 7px rgba(148,163,184,0.75);
    }

    .top-icon-btn:hover {
      background: var(--btn-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    }

    .top-icon-btn.contact    { border-color: #facc15; }
    .top-icon-btn.briefing   { border-color: #a855f7; }
    .top-icon-btn.help       { border-color: #e5e7eb; }
    .top-icon-btn.export     { border-color: var(--accent); background: var(--accent-soft); }

    #optionsToggle {
      display: none;
    }

    .icon-hint {
      font-size: 12px;
      color: var(--text-sub);
      min-height: 16px;
      text-align: center;
    }

    /* MENU EXPORT */

    .export-menu-wrapper {
      position: relative;
      display: inline-block;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 10px;
      padding: 6px 0;
      min-width: 250px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.65);
      z-index: 900;
    }

    .export-menu button {
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text-main);
      text-align: left;
      padding: 8px 12px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      white-space: nowrap;
    }

    .export-menu button span.icon {
      font-size: 16px;
      width: 18px;
      text-align: center;
    }

    .export-menu button:hover {
      background: var(--accent-soft);
    }

    .hidden { display: none; }

    /* Ligne Source + mid-box + Zoom */
    .source-zoom-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }

    .source-box,
    .zoom-box,
    .mid-box {
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.35);
      min-width: 230px;
    }

    :root[data-theme="light"] .source-box,
    :root[data-theme="light"] .zoom-box,
    :root[data-theme="light"] .mid-box {
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    .source-box strong,
    .zoom-box strong,
    .mid-box strong {
      display: block;
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 4px;
      text-align: center;
    }

    .source-box label,
    .mid-box label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }

    .source-box input[type="file"] {
      color: var(--text-sub);
      max-width: 180px;
    }

    .zoom-box label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }

    #zoomRange {
      width: 120px;
      margin-left: 4px;
    }

    #zoomNumber {
      width: 60px;
      margin-left: 6px;
      background: #090c14;
      border: 1px solid #32394b;
      border-radius: 6px;
      color: var(--text-main);
      padding: 2px 6px;
    }

    :root[data-theme="light"] #zoomNumber {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    .shortcut-hint {
      font-size: 11px;
      color: var(--text-sub);
      margin-top: 4px;
      text-align: center;
    }

    /* Toolbar APPLIQUER / SUPPRIMER ‚Äì STICKY */

    .toolbar-main {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;

      position: sticky;
      top: 0;
      z-index: 500;

      background: radial-gradient(circle at top, rgba(8,10,15,0.98), rgba(8,10,15,0.95));
      padding: 6px 14px;
      margin-bottom: 8px;
      border-radius: 999px;
      border: 1px solid rgba(60,68,90,0.9);
      box-shadow: 0 4px 16px rgba(0,0,0,0.7);
    }

    :root[data-theme="light"] .toolbar-main {
      background: rgba(249,250,251,0.96);
      border-color: #d1d5db;
      box-shadow: 0 4px 12px rgba(148,163,184,0.8);
    }

    .toolbar-main button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .toolbar-main .undo-redo-btn {
      padding: 10px 14px;
      font-size: 18px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      min-width: 50px;
    }

    .toolbar-main .undo-redo-btn:hover {
      background: var(--btn-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }

    .toolbar-main .undo-redo-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    :root[data-theme="light"] .toolbar-main .undo-redo-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    /* APPLIQUER (vert) */
    #drawBtn {
      font-size: 17px;
      font-weight: 600;
      min-width: 180px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid var(--success);
      background: var(--success-soft);
      color: var(--text-main);
      box-shadow: 0 0 10px rgba(34,197,94,0.7);
    }

    #drawBtn:hover {
      background: rgba(34,197,94,0.27);
      transform: translateY(-1px);
    }

    /* SUPPRIMER (rouge) */
    #undoDeleteBtn {
      font-size: 14px;
      min-width: 150px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--danger);
      background: var(--danger-soft);
      color: var(--text-main);
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
    }

    :root[data-theme="light"] #undoDeleteBtn {
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    #undoDeleteBtn:hover {
      background: rgba(220,38,38,0.22);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }

    /* AUTO (bleu, taille = SUPPRIMER) */
    #autoRefreshBtn {
      font-size: 14px;
      min-width: 150px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: var(--accent-soft);
      color: var(--text-main);
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
    }

    :root[data-theme="light"] #autoRefreshBtn {
      box-shadow: 0 2px 7px rgba(148,163,184,0.7);
    }

    #autoRefreshBtn:hover {
      background: rgba(37,99,235,0.22);
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }

    /* Portrait / Paysage ic√¥ne rectangle + fl√®che */
    #orientationToggle { border-color: var(--accent); }
    :root[data-theme="light"] #orientationToggle { border-color: var(--accent); }

    #orientationToggle .orient-icon {
      display: inline-block;
      width: 20px;
      height: 16px;
      border-radius: 3px;
      border: 2px solid currentColor;
      position: relative;
      box-sizing: border-box;
    }

    #orientationToggle .orient-icon::before {
      content: "";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
    }

    #orientationToggle .orient-portrait::before {
      content: "‚Üï";
    }

    #orientationToggle .orient-landscape::before {
      content: "‚Üî";
    }

    /* Reset dans la toolbar */
    #resetBtn {
      border-color: var(--danger);
      background: var(--danger-soft);
    }

    :root[data-theme="light"] #resetBtn {
      border-color: var(--danger);
      background: var(--danger-soft);
    }

    /* Feuilles dans le bandeau */

    .sheet-buttons {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      justify-content: center;
    }

    .sheet-buttons button {
      padding: 4px 8px;
      font-size: 14px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
    }

    .sheet-buttons button:hover {
      background: var(--btn-bg-hover);
    }

    .sheet-select-inline {
      width: 120px;
      margin-left: 4px;
      border-radius: 6px;
      border: 1px solid var(--border-panel);
      background: #090c14;
      color: var(--text-main);
      padding: 2px 4px;
    }

    :root[data-theme="light"] .sheet-select-inline {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    /* LAYOUT PRINCIPAL */

    .main-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      margin-top: 10px;
    }

    .canvas-wrapper {
      flex: 1;
      min-width: 300px;
      position: relative;
    }

    .canvas-scroll {
      overflow: visible;
      border-radius: 8px;
    }

    .side-panel {
      flex: 0 0 480px;
      max-width: 500px;
      align-self: flex-start;
      position: sticky;
      top: 0;
      z-index: 400;
    }

    body.briefing-mode .side-panel { display: none; }
    body.briefing-mode .canvas-wrapper { flex: 1 1 auto; }

    /* BLOC OPTIONS */
    .controls {
      display: grid;
      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
      gap: 8px;
      background: var(--bg-panel);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border-panel);
      box-shadow: 0 0 16px rgba(0,0,0,0.45);
    }

    :root[data-theme="light"] .controls {
      box-shadow: 0 4px 10px rgba(148,163,184,0.45);
    }

    label {
      font-size: 13px;
      color: var(--text-sub);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }

    input[type="number"],
    input[type="range"],
    select,
    input[type="text"] {
      font-size: 13px;
    }

    input[type="number"] {
      margin-left: 4px;
      background: #090c14;
      border: 1px solid #32394b;
      border-radius: 6px;
      color: var(--text-main);
      padding: 2px 6px;
      width: 60px;
    }

    :root[data-theme="light"] input[type="number"] {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    input[type="range"] {
      width: 120px;
      margin-left: 4px;
    }

    select {
      margin-left: 4px;
      padding: 2px 4px;
      border-radius: 6px;
      border: 1px solid #32394b;
      background: #090c14;
      color: var(--text-main);
    }

    :root[data-theme="light"] select {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    input[type="text"] {
      margin-left: 4px;
      padding: 2px 4px;
      border-radius: 6px;
      border: 1px solid #32394b;
      background: #090c14;
      color: var(--text-main);
      width: 130px;
    }

    :root[data-theme="light"] input[type="text"] {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #111827;
    }

    .group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 13px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(7, 10, 18, 0.7);
      border: 1px solid rgba(60,68,90,0.9);
    }

    :root[data-theme="light"] .group {
      background: #f9fafb;
      border-color: #d1d5db;
    }

    .group strong {
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 4px;
      white-space: nowrap;
      text-align: center;
    }

    .group-full { grid-column: 1 / -1; }

    .selection-modes,
    .selection-modes-second {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .selection-mode-btn {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #2c3345;
      background: var(--btn-bg);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 6px rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }

    :root[data-theme="light"] .selection-mode-btn {
      border-color: #d1d5db;
      box-shadow: 0 2px 4px rgba(148,163,184,0.6);
    }

    .selection-mode-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .selection-mode-btn span.icon {
      font-size: 16px;
      width: 18px;
      text-align: center;
    }

    .border-width-options {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
    }

    .border-width-options span.label-title {
      color: var(--text-sub);
      font-size: 12px;
      margin-right: 4px;
      white-space: nowrap;
    }

    canvas {
      border: 1.5px solid #3a4158;
      display: block;
      margin-top: 12px;
      background: var(--canvas-bg);
      transition: background 0.25s ease, border-color 0.25s ease;
      max-width: 100%;
    }

    :root[data-theme="light"] canvas { border-color: #cbd5e1; }

    #msg {
      margin-top: 8px;
      font-size: 12px;
      color: #ffb74d;
    }

    :root[data-theme="light"] #msg { color: #b45309; }

    footer {
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-sub);
      text-align: center;
    }

    /* AIDE / MODAL */

    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .help-overlay.hidden { display: none !important; }

    .help-modal {
      position: relative;
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 12px;
      padding: 16px 20px 14px 20px;
      max-width: 520px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 12px 30px rgba(0,0,0,0.7);
    }

    .help-modal h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: var(--accent);
    }

    .help-modal h3 {
      margin: 8px 0 4px 0;
      font-size: 14px;
      color: var(--text-main);
    }

    .help-modal p,
    .help-modal li {
      font-size: 13px;
      color: var(--text-sub);
      line-height: 1.4;
    }

    .help-modal ul {
      padding-left: 18px;
      margin: 4px 0 6px 0;
    }

    .help-close {
      border: none;
      background: transparent;
      color: var(--text-sub);
      font-size: 18px;
      cursor: pointer;
      position: absolute;
      top: 6px;
      right: 8px;
    }

    .help-close:hover { color: var(--text-main); }

    details { margin-top: 6px; }

    details > summary {
      cursor: pointer;
      font-size: 13px;
      color: var(--accent);
      list-style: none;
    }

    details > summary::-webkit-details-marker { display: none; }

    details > summary::before {
      content: "‚ñ∏ ";
      font-size: 12px;
    }

    details[open] > summary::before { content: "‚ñæ "; }

    /* Infobulle S√©lection de case (ic√¥ne ?) */
    .zone-help-wrapper {
      display: flex;
      justify-content: center;
      position: relative;
      margin: 2px 0 6px;
    }

    .case-help-btn {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid var(--border-panel);
      font-size: 16px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 0 6px rgba(0,0,0,0.45);
    }

    :root[data-theme="dark"] .case-help-btn {
      background: #ffffff;
      color: #000000;
    }

    :root[data-theme="light"] .case-help-btn {
      background: #000000;
      color: #ffffff;
    }

    .help-tooltip-inline {
      position: absolute;
      top: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-panel);
      border: 1px solid var(--border-panel);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text-sub);
      width: 360px;
      max-width: 95vw;
      max-height: 60vh;
      overflow-y: auto;
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
      z-index: 1100;
    }

    .shortcut-key {
      color: #60a5fa;
      font-weight: 600;
    }

    .zone-color-group-line label {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }

    /* ===================== RESPONSIVE T√âL√âPHONE ===================== */

    @media (max-width: 900px) {
      body { margin: 10px; }

      .main-layout { flex-direction: column; }

      .canvas-wrapper { width: 100%; }

      .side-panel {
        position: static;
        width: 100%;
        max-width: 100%;
        margin-top: 10px;
        display: flex;
        justify-content: center;
      }

      body.options-collapsed .side-panel { display: none; }

      .zoom-box { display: none; }

      .controls {
        grid-template-columns: 1fr;
        transform: scale(0.95);
        transform-origin: top center;
        margin: 0 auto;
      }

      .toolbar-main {
        top: 0;
        border-radius: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      /* MODE MOBILE PAYSAGE */
      .mobile-landscape .toolbar-main #undoBtn,
      .mobile-landscape .toolbar-main #redoBtn,
      .mobile-landscape .toolbar-main #undoDeleteBtn,
      .mobile-landscape .toolbar-main #autoRefreshBtn,
      .mobile-landscape .toolbar-main #orientationToggle,
      .mobile-landscape .toolbar-main #resetBtn,
      .mobile-landscape .toolbar-main #optionsToggle {
        order: 1;
        flex: 0 1 auto;
      }
      .mobile-landscape .toolbar-main #drawBtn {
        order: 2;
        flex-basis: 100%;
        max-width: 230px;
        justify-content: center;
      }

      /* MODE MOBILE PORTRAIT
         L1 : portrait + corbeille
         L2 : ‚Ü© + ‚Ü™
         L3 : SUPPRIMER + AUTO
         L4 : APPLIQUER
         L5 : OPTIONS
      */
      .mobile-portrait .toolbar-main #orientationToggle,
      .mobile-portrait .toolbar-main #resetBtn,
      .mobile-portrait .toolbar-main #undoBtn,
      .mobile-portrait .toolbar-main #redoBtn,
      .mobile-portrait .toolbar-main #undoDeleteBtn,
      .mobile-portrait .toolbar-main #autoRefreshBtn {
        flex: 1 1 calc(50% - 6px);
        max-width: none;
      }

      .mobile-portrait .toolbar-main #drawBtn,
      .mobile-portrait .toolbar-main #optionsToggle {
        flex: 1 1 100%;
        max-width: none;
      }

      .mobile-portrait .toolbar-main #orientationToggle,
      .mobile-portrait .toolbar-main #resetBtn { order: 1; }

      .mobile-portrait .toolbar-main #undoBtn,
      .mobile-portrait .toolbar-main #redoBtn { order: 2; }

      .mobile-portrait .toolbar-main #undoDeleteBtn,
      .mobile-portrait .toolbar-main #autoRefreshBtn { order: 3; }

      .mobile-portrait .toolbar-main #drawBtn { order: 4; }

      .mobile-portrait .toolbar-main #optionsToggle { order: 5; }

      /* CENTRAGE DES BLOCS SOURCE / FEUILLES / PARAM√àTRES / L√âGENDE */
      .source-zoom-row {
        flex-direction: column;
        align-items: center;
      }
      .source-zoom-row > .source-box,
      .source-zoom-row > .mid-box,
      .source-zoom-row > .zoom-box {
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
      }

      .system-icons { justify-content: center; }

      #optionsToggle { display: inline-flex; }

      label { font-size: 12px; }
      .group { font-size: 12px; }

      canvas { height: auto; }

      /* MENU EXPORT CENTR√â √âCRAN SUR T√âL√âPHONE */
      .export-menu {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        right: auto;
        width: min(260px, 90vw);
      }
    }

    /* Uniformisation hauteur des cadres + titres align√©s (desktop) */
    @media (min-width: 901px) {
      .source-zoom-row { align-items: stretch; }
      .source-zoom-row > .source-box,
      .source-zoom-row > .mid-box,
      .source-zoom-row > .zoom-box {
        display: grid;
        grid-template-rows: auto 1fr;
      }
      .source-zoom-row > .source-box > strong,
      .source-zoom-row > .mid-box > strong,
      .source-zoom-row > .zoom-box > strong {
        align-self: start;
      }
    }
  </style>
  <!-- jsPDF pour export PDF direct -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <header class="header">
    <div class="logo-mark">
      <div class="logo-cell logo-yellow"></div>
      <div class="logo-cell logo-blue"></div>
      <div class="logo-cell logo-green"></div>
      <div class="logo-cell logo-red"></div>
    </div>
    <div class="logo-text">
      <div class="logo-text-main">QuadRico</div>
      <div class="logo-text-sub">G√©n√©rateur de quadrillage tactique</div>
    </div>
  </header>

  <div class="top-bar-main">
    <div id="contactInfo" class="contact-info"></div>

    <div class="system-icons">
      <button id="themeToggle" class="top-icon-btn" aria-label="Basculer mode jour/sombre">
        <span class="theme-toggle-icon">‚òØ</span>
      </button>
      <button id="fullscreenToggle" class="top-icon-btn" aria-label="Basculer plein √©cran">
        ‚õ∂
      </button>
      <button id="briefingBtn" class="top-icon-btn briefing" aria-label="Mode briefing">
        üé¨
      </button>

      <!-- Aide + contact (GUIDE D√âTAILL√â ici) -->
      <button id="helpBtn" class="top-icon-btn help" aria-label="Aide d√©taill√©e / guide rapide">
        ‚ùì
      </button>

      <!-- MENU EXPORT / IMPRESSION -->
      <div class="export-menu-wrapper">
        <button id="exportMenuBtn" class="top-icon-btn export" aria-label="Exporter / imprimer">
          üì§
        </button>
        <div id="exportMenu" class="export-menu hidden">
          <button id="exportPngBtn" type="button">
            <span class="icon">üñºÔ∏è</span> Enregistrer l'image en PNG
          </button>
          <button id="exportPdfBtn" type="button">
            <span class="icon">üìÑ</span> Enregistrer en PDF
          </button>
          <button id="exportGridOnlyBtn" type="button">
            <span class="icon">#</span> Enregistrer le quadrillage (sans la carto)
          </button>
          <button id="exportPrintBtn" type="button">
            <span class="icon">üñ®Ô∏è</span> Imprimer
          </button>
          <button id="exportMailBtn" type="button">
            <span class="icon">‚úâ</span> Envoyer par mail
          </button>
          <button id="exportWhatsappBtn" type="button">
            <span class="icon">üí¨</span> Envoyer par WhatsApp
          </button>
          <button id="loadScenarioBtn" type="button">
            <span class="icon">üìÇ</span> Charger sc√©nario QuadRico (.json)
          </button>
        </div>
      </div>

      <button id="contactBtn" class="top-icon-btn contact" aria-label="Mail concepteur QuadRico">
        ‚úâ
      </button>
    </div>

    <div id="iconHint" class="icon-hint"></div>

    <div class="source-zoom-row">
      <!-- SOURCE -->
      <div class="source-box">
        <strong>Source</strong>
        <label>
          <span>Image :</span>
          <input type="file" id="imageLoader" accept="image/*">
        </label>
        <label>
          <span>Adresse Google Maps :</span>
          <span style="display:flex;gap:4px;align-items:center;">
            <input type="text" id="mapsAddress" placeholder="Ex : 10 Rue ..., Ville">
            <button id="mapsOpenBtn" type="button" class="selection-mode-btn" style="padding:4px 8px;font-size:11px;">
              üîç
            </button>
          </span>
        </label>
        <label>
          <span>Grille sans image</span>
          <input type="checkbox" id="gridOnly">
        </label>
      </div>

      <!-- Feuilles -->
      <div class="mid-box">
        <strong>Feuilles</strong>
        <label>
          <span>Feuille :</span>
          <select id="sheetSelect" class="sheet-select-inline"></select>
        </label>
        <div class="sheet-buttons">
          <button id="addSheetBtn" title="Ajouter une feuille">Ôºã</button>
          <button id="renameSheetBtn" title="Renommer la feuille">‚úé</button>
          <button id="duplicateSheet1Btn" title="Copier la feuille affich√©e">‚ßâ</button>
          <button id="deleteSheetBtn" title="Supprimer la feuille">üóë</button>
        </div>
      </div>

      <div class="mid-box">
        <strong>Param√®tres de grille</strong>
        <label>
          <span>Colonnes :</span>
          <input type="number" id="cols" value="10" min="1">
        </label>
        <label>
          <span>Lignes :</span>
          <input type="number" id="rows" value="14" min="1">
        </label>
      </div>

      <div class="mid-box">
        <strong>L√©gende</strong>
        <label>
          <span>Mode de l√©gende :</span>
          <select id="legendModeSelect">
            <option value="none">Pas de l√©gende</option>
            <option value="partial">L√©gende partielle (2 c√¥t√©s)</option>
            <option value="full" selected>L√©gende totale (4 c√¥t√©s)</option>
          </select>
        </label>
      </div>

      <div class="zoom-box">
        <strong>Zoom & vue</strong>
        <label>
          <span>Zoom :</span>
          <span>
            <input type="range" id="zoomRange" min="50" max="300" value="100">
            <span id="zoomValue">100%</span>
            <input type="number" id="zoomNumber" min="50" max="300" value="100">
          </span>
        </label>
        <div class="shortcut-hint">Raccourcis : Ctrl + molette</div>
      </div>
    </div>
  </div>

  <div class="main-layout">
    <div class="canvas-wrapper">
      <div class="toolbar-main">
        <button id="undoBtn" class="undo-redo-btn" title="Retour en arri√®re">
          ‚Ü©
        </button>
        <button id="redoBtn" class="undo-redo-btn" title="Retour en avant">
          ‚Ü™
        </button>
        <button id="undoDeleteBtn">
          SUPPRIMER
        </button>
        <button id="autoRefreshBtn" class="undo-redo-btn" title="Rafra√Æchissement auto">
          AUTO
        </button>
        <button id="orientationToggle" class="undo-redo-btn" aria-label="Portrait / Paysage (affichage)">
          <span class="orient-icon orient-portrait"></span>
        </button>
        <button id="resetBtn" class="undo-redo-btn" aria-label="Effacer / Reset">
          üóë
        </button>
        <button id="drawBtn">
          APPLIQUER
        </button>
        <button id="optionsToggle" class="undo-redo-btn" aria-label="Afficher / masquer les options">
          ‚öô
        </button>
      </div>

      <!-- checkbox technique autoRefresh cach√©e -->
      <input type="checkbox" id="autoRefresh" style="display:none;">

      <div class="canvas-scroll">
        <canvas id="canvas"></canvas>
      </div>
      <div id="msg"></div>
    </div>

    <div class="side-panel">
      <div class="controls">
        <div class="group">
          <strong>Choix du type de quadrillage</strong>
          <select id="gridTypeSelect">
            <option value="none">Aucun</option>
            <option value="uni-black">Noir</option>
            <option value="uni-red">Rouge</option>
            <option value="fsi" selected>FSI (4 couleurs)</option>
          </select>
        </div>

        <div class="group">
          <strong>Choix du type de code dans les cases</strong>
          <select id="labelModeSelect">
            <option value="none" selected>Aucun code</option>
            <option value="uni">Code noir</option>
            <option value="color">Code rouge</option>
            <option value="fsi-color">Code FSI</option>
          </select>
        </div>

        <div class="group">
          <strong>Style des lignes</strong>
          <label>
            <span>Pointill√©s</span>
            <input type="checkbox" id="dashedLines">
          </label>
          <label>
            <span>Croix (noir)</span>
            <input type="checkbox" id="crossBlack">
          </label>
          <label>
            <span>Croix (rouge)</span>
            <input type="checkbox" id="crossRed">
          </label>
          <label>
            <span>Croix (FSI)</span>
            <input type="checkbox" id="crossFSI">
          </label>
        </div>

        <div class="group">
          <strong>Opacit√©</strong>
          <label>
            <span>Image :</span>
            <input type="range" id="imageOpacity" min="0" max="100" value="100">
          </label>
          <label>
            <span>Quadrillage :</span>
            <input type="range" id="gridOpacity" min="0" max="100" value="100">
          </label>
          <label>
            <span>Code / Croix :</span>
            <input type="range" id="codeOpacity" min="0" max="100" value="100">
          </label>
          <label>
            <span>Zone color√©e :</span>
            <input type="range" id="fillOpacity" min="0" max="100" value="35">
          </label>
        </div>

        <div class="group group-full">
          <strong>S√©lection de case</strong>

          <!-- IC√îNE "?" + TEXTE R√âSUM√â (version raccourcie) -->
          <div id="zoneHelpWrapper" class="zone-help-wrapper">
            <button id="fillHelpIcon" type="button" class="case-help-btn">?</button>
            <div id="fillHelpTooltip" class="help-tooltip-inline hidden">
              <strong>Utilisation rapide</strong><br>
              ‚Ä¢ Choisis un mode : <em>Appliquer</em>, <em>Effacer bordure</em>, <em>Effacer texte/croix</em>, <em>Fusionner</em>, <em>Fractionner</em> ou <em>R√©initialiser</em>.<br>
              ‚Ä¢ Clique ensuite directement sur la case √† modifier.<br><br>

              <strong>Zones color√©es</strong><br>
              ‚Ä¢ <em>Couleur de zone</em> = couleur appliqu√©e sur la case (surface color√©e).<br>
              ‚Ä¢ <em>(n√©ant)</em> = aucune zone color√©e (ou suppression de la zone existante).<br>
              ‚Ä¢ L‚Äôintensit√© est r√©gl√©e avec le curseur <strong>¬´ Zone color√©e ¬ª</strong> (rubrique Opacit√©) au moment o√π tu appliques.<br><br>

              <strong>Texte, codes & croix</strong><br>
              ‚Ä¢ Si tu saisis un <strong>texte</strong> dans la case, les <strong>codes automatiques</strong> (A1, B3, ‚Ä¶) et les <strong>croix</strong> sont d√©sactiv√©s pour cette case.<br>
              ‚Ä¢ Pour revenir au quadrillage d‚Äôorigine sur une bordure personnalis√©e, mets <strong>Couleur de bordure = (n√©ant)</strong> puis clique sur la case concern√©e.
            </div>
          </div>

          <div class="selection-modes">
            <button id="modeApply" class="selection-mode-btn active" type="button" title="Appliquer sur la case">
              <span class="icon">‚úé</span> Appliquer
            </button>
            <button id="modeEraseBorder" class="selection-mode-btn" type="button" title="Effacer bordure / quadrillage">
              <span class="icon">‚¨ö</span> Effacer bordure
            </button>
            <button id="modeEraseCode" class="selection-mode-btn" type="button" title="Effacer texte/croix">
              <span class="icon">‚úï</span> Effacer texte/croix
            </button>
          </div>

          <div class="selection-modes-second">
            <button id="modeMerge" class="selection-mode-btn" type="button" title="Fusionner les cases">
              <span class="icon">‚ñ©</span> Fusionner
            </button>
            <button id="modeSplit" class="selection-mode-btn" type="button" title="Fractionner les cases">
              <span class="icon">‚ñ¢</span> Fractionner
            </button>
            <button id="modeReset" class="selection-mode-btn" type="button" title="R√©initialiser la case">
              <span class="icon">‚≠Æ</span> R√©initialiser
            </button>
          </div>

          <div class="border-width-options">
            <span class="label-title">√âpaisseur du trait :</span>
            <label>
              <span>Normal</span>
              <input type="radio" name="borderWidth" value="normal" checked>
            </label>
            <label>
              <span>√âpais</span>
              <input type="radio" name="borderWidth" value="epais">
            </label>
            <label>
              <span>Tr√®s √©pais</span>
              <input type="radio" name="borderWidth" value="tres-epais">
            </label>
          </div>

          <label>
            <span>Couleur de bordure :</span>
            <select id="borderColor">
              <option value="none">(n√©ant)</option>
              <option value="#000000">Noir</option>
              <option value="#ff0000">Rouge</option>
              <option value="#0000ff">Bleu</option>
              <option value="#00aa00">Vert</option>
              <option value="#ffaa00">Orange</option>
              <option value="#ffff00">Jaune</option>
              <option value="#aa00ff">Violet</option>
              <option value="#00ffff">Cyan</option>
              <option value="#ff00aa">Magenta</option>
              <option value="#ffffff">Blanc</option>
            </select>
          </label>
          <label>
            <span>Texte dans la case :</span>
            <input type="text" id="cellText" placeholder="Ex : TO, Appui 1...">
          </label>
          <label>
            <span>Couleur du texte :</span>
            <select id="textColor">
              <option value="">(M√™me que bordure)</option>
              <option value="#000000">Noir</option>
              <option value="#ff0000">Rouge</option>
              <option value="#0000ff">Bleu</option>
              <option value="#00aa00">Vert</option>
              <option value="#ffaa00">Orange</option>
              <option value="#ffff00">Jaune</option>
              <option value="#aa00ff">Violet</option>
              <option value="#00ffff">Cyan</option>
              <option value="#ff00aa">Magenta</option>
              <option value="#ffffff">Blanc</option>
            </select>
          </label>

          <div class="zone-color-group-line">
            <label>
              <span>Couleur de zone :</span>
              <select id="fillColor">
                <option value="none">(n√©ant)</option>
                <option value="rgba(255,0,0,0.6)">Rouge</option>
                <option value="rgba(0,128,0,0.6)">Vert</option>
                <option value="rgba(0,0,255,0.6)">Bleu</option>
                <option value="rgba(255,255,0,0.6)">Jaune</option>
                <option value="rgba(255,165,0,0.6)">Orange</option>
                <option value="rgba(128,0,128,0.6)">Violet</option>
                <option value="rgba(255,255,255,0.6)">Blanc</option>
                <option value="rgba(0,0,0,0.6)">Noir</option>
              </select>
            </label>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Overlay AIDE SIMPLE au d√©marrage -->
  <div id="welcomeOverlay" class="help-overlay">
    <div class="help-modal" role="dialog" aria-modal="true" aria-labelledby="welcomeTitle">
      <button id="closeWelcomeBtn" class="help-close" aria-label="Fermer l'aide rapide">‚úï</button>
      <h2 id="welcomeTitle">QuadRico ‚Äì D√©marrage rapide</h2>
      <p><strong>1.</strong> Charge une image ou coche <strong>Grille sans image</strong>.</p>
      <p><strong>2.</strong> R√®gle le nombre de <strong>colonnes / lignes</strong>.</p>
      <p><strong>3.</strong> Choisis ton type de quadrillage puis clique sur <strong>APPLIQUER</strong> (ou touche <strong>Entr√©e</strong>).</p>
      <p><strong>4.</strong> Clique sur les cases pour :</p>
      <ul>
        <li>ajouter bordure / texte / zone color√©e (avec l‚Äôopacit√© choisie dans ¬´ Opacit√© &gt; Zone color√©e ¬ª),</li>
        <li>effacer bordure ou texte,</li>
        <li>fusionner / fractionner / r√©initialiser une case.</li>
      </ul>
      <p><strong>Raccourcis principaux :</strong>  
        Entr√©e (APPLIQUER), Ctrl + Z, Ctrl + C / Ctrl + V,  
        Ctrl + molette (zoom), Suppr (Delete) = r√©initialiser la derni√®re case cliqu√©e.
      </p>
      <p>Pour l‚Äôexport, utilise le bouton <strong>üì§</strong> (PNG, PDF, quadrillage seul, impression, mail, WhatsApp, sc√©nario).  
         Pour plus de d√©tails, clique sur <strong>‚ùì</strong> ou active <strong>AUTO</strong> √† droite d‚ÄôAPPLIQUER pour le rafra√Æchissement automatique.</p>
    </div>
  </div>

  <!-- Overlay AIDE D√âTAILL√âE (bouton ‚ùì) -->
  <div id="helpOverlay" class="help-overlay hidden">
    <div class="help-modal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <button id="closeHelpBtn" class="help-close" aria-label="Fermer l'aide">‚úï</button>
      <h2 id="helpTitle">Guide complet QuadRico</h2>

      <details open>
        <summary>1. Source & affichage</summary>
        <ul>
          <li><strong>Image</strong> : importe une photo (satellite, plan, croquis, etc.).</li>
          <li><strong>Adresse Google Maps</strong> : saisis une adresse ou un lieu puis üîç pour ouvrir dans un nouvel onglet.</li>
          <li><strong>Grille sans image</strong> : quadrillage seul (fond noir / blanc selon le th√®me).</li>
          <li><strong>Bouton ‚ñØ‚Üï / ‚ñ≠‚Üî</strong> : fait pivoter l‚Äôaffichage de la carte (portrait / paysage) pour adapter la vue.  
              L‚Äôorientation d‚Äôimpression est ensuite adapt√©e automatiquement √† la forme de la carte.</li>
        </ul>
      </details>

      <details>
        <summary>2. Quadrillage & l√©gende</summary>
        <ul>
          <li><strong>Colonnes / Lignes</strong> : taille de la grille (A1, B3, ‚Ä¶).</li>
          <li><strong>Quadrillage</strong> : aucun / noir / rouge / FSI (menu d√©roulant).</li>
          <li><strong>L√©gende</strong> : pas de l√©gende / partielle (2 c√¥t√©s) / totale (4 c√¥t√©s) (menu d√©roulant).</li>
          <li><strong>Rafra√Æchissement auto (AUTO)</strong> : si activ√©, la carte se met √† jour d√®s que tu modifies un param√®tre g√©n√©ral (grille, opacit√©, etc.).</li>
          <li>Les colonnes suivent la logique <strong>A, B, ‚Ä¶, Z, AA, AB, ‚Ä¶</strong>.</li>
        </ul>
      </details>

      <details>
        <summary>3. Codes, croix & zones color√©es</summary>
        <ul>
          <li><strong>Type de code</strong> (menu d√©roulant) : aucun / noir / rouge / FSI.</li>
          <li><strong>Croix</strong> : noir, rouge ou FSI (une seule couleur √† la fois).</li>
          <li><strong>Couleur de zone</strong> :
            <ul>
              <li><em>(n√©ant)</em> : aucune zone color√©e pour la case (ou suppression de la zone existante).</li>
              <li>Couleur (rouge, vert, ‚Ä¶) : zone color√©e semi-transparente.</li>
              <li>L‚Äôopacit√© est r√©gl√©e par le curseur <strong>¬´ Zone color√©e ¬ª</strong> dans la rubrique <strong>Opacit√©</strong>.</li>
            </ul>
          </li>
        </ul>
      </details>

      <details>
        <summary>4. Bordures & texte</summary>
        <ul>
          <li><strong>Couleur de bordure</strong> :
            <ul>
              <li><em>(n√©ant)</em> : supprime la couleur personnalis√©e et revient √† la <strong>couleur du quadrillage de base</strong> pour la case.</li>
              <li>Couleur (noir, rouge, ‚Ä¶) : bordure forc√©e dans cette couleur (utile pour d√©limiter une zone).</li>
            </ul>
          </li>
          <li><strong>√âpaisseur</strong> :
            <ul>
              <li><em>Normal</em> : m√™me √©paisseur que le quadrillage de base.</li>
              <li><em>√âpais / Tr√®s √©pais</em> : traits plus visibles pour marquer une zone.</li>
            </ul>
          </li>
          <li><strong>Texte dans la case</strong> : TO, Appui 1, G1, etc.  
              Si du texte est pr√©sent, les codes/croix automatiques sont d√©sactiv√©s sur la case.</li>
        </ul>
      </details>

      <details>
        <summary>5. Travail par case</summary>
        <ul>
          <li>Clique sur une case pour appliquer le mode choisi :</li>
          <li><strong>Appliquer</strong> : bordure + texte + zone color√©e selon les r√©glages.</li>
          <li><strong>Effacer bordure</strong> : supprime le trait (ou le trait du bloc fusionn√©) et la personnalisation de la bordure.</li>
          <li><strong>Effacer texte/croix</strong> : supprime texte, codes et croix.</li>
          <li><strong>Fusionner / Fractionner</strong> : cr√©er ou casser des blocs multi-cases (uniquement pour la bordure et le texte).  
              La <strong>couleur de zone et son opacit√©</strong> restent g√©r√©es case par case, m√™me si les cases sont fusionn√©es.</li>
          <li><strong>R√©initialiser la case</strong> : revient √† la case d‚Äôorigine.</li>
          <li><strong>Ctrl + C / Ctrl + V</strong> : copie / colle le style d‚Äôune case (bordure, texte, zone, opacit√©‚Ä¶).</li>
          <li><strong>Suppr (Delete)</strong> : r√©initialiser la derni√®re case cliqu√©e.</li>
        </ul>
      </details>

      <details>
        <summary>6. Onglets / feuilles</summary>
        <ul>
          <li><strong>Feuille</strong> : menu d√©roulant dans le bandeau.</li>
          <li><strong>Ôºã</strong> : nouvelle feuille, sans image (tu peux charger une autre carte).</li>
          <li><strong>‚úé</strong> : renommer la feuille.</li>
          <li><strong>‚ßâ</strong> : duplique la feuille affich√©e (image + sc√©nario).</li>
          <li><strong>üóë</strong> : supprime la feuille (sauf la derni√®re).</li>
        </ul>
      </details>

      <details>
        <summary>7. Export, impression & briefing (ic√¥nes de contr√¥le)</summary>
        <ul>
          <li><strong>‚òØ</strong> : mode sombre / clair.</li>
          <li><strong>‚ñØ‚Üï / ‚ñ≠‚Üî</strong> : fait pivoter l‚Äôaffichage de la carte (portrait / paysage).  
              L‚Äôorientation papier est ensuite adapt√©e automatiquement √† la forme de la carte.</li>
          <li><strong>‚õ∂</strong> : plein √©cran.</li>
          <li><strong>üé¨</strong> : mode briefing (affiche uniquement la carte).</li>
          <li><strong>üì§ Export / Imprimer</strong> (menu d√©roulant) :
            <ul>
              <li><strong>Enregistrer l'image en PNG</strong> : exporte la carte quadrill√©e en image.</li>
              <li><strong>Enregistrer en PDF</strong> : g√©n√®re automatiquement un PDF en portrait ou paysage selon la forme de la carte.</li>
              <li><strong>Enregistrer le quadrillage (sans la carto)</strong> : sauvegarde le quadrillage au format JSON, <strong>sans l‚Äôimage de fond</strong>.</li>
              <li><strong>Imprimer</strong> : ouvre la fen√™tre d‚Äôimpression avec la carte centr√©e et une orientation de page adapt√©e √† la forme de la carte.</li>
              <li><strong>Envoyer par mail</strong> : t√©l√©charge le PNG, puis ouvre soit Gmail Web sur ordinateur, soit ton application mail par d√©faut sur t√©l√©phone (ajoute le fichier en pi√®ce jointe).</li>
              <li><strong>Envoyer par WhatsApp</strong> : t√©l√©charge le PNG puis ouvre WhatsApp (web ou appli) avec un message pr√©-rempli.</li>
              <li><strong>Charger sc√©nario QuadRico (.json)</strong> : charge un sc√©nario pr√©c√©demment sauvegard√©.</li>
            </ul>
          </li>
          <li><strong>üóë</strong> : reset complet apr√®s confirmation.</li>
          <li><strong>‚úâ</strong> (icone concepteur) : ouvre un mail de contact vers le concepteur (Gmail Web sur ordinateur ou appli mail par d√©faut sur t√©l√©phone).</li>
        </ul>
      </details>

      <details>
        <summary>8. Raccourcis clavier</summary>
        <ul>
          <li><strong>Entr√©e</strong> : APPLIQUER.</li>
          <li><strong>Ctrl + Z</strong> : annuler.</li>
          <li><strong>Ctrl + C</strong> : copier le style de la derni√®re case cliqu√©e.</li>
          <li><strong>Ctrl + V</strong> : coller le style copi√© sur la derni√®re case cliqu√©e.</li>
          <li><strong>Ctrl + molette</strong> : zoom sur la carte.</li>
          <li><strong>Suppr (Delete)</strong> : r√©initialiser la derni√®re case cliqu√©e.</li>
        </ul>
      </details>
    </div>
  </div>

  <footer>
    QuadRico ‚Äì Outil libre d'utilisation, non contractuel.  
    G√©n√©rateur de quadrillage mis √† disposition √† titre gratuit pour un usage p√©dagogique et op√©rationnel.
  </footer>

  <!-- Input cach√© pour charger un sc√©nario JSON -->
  <input type="file" id="scenarioFileInput" accept="application/json" style="display:none;">

  <script>
    const imageLoader   = document.getElementById('imageLoader');
    const canvas        = document.getElementById('canvas');
    const ctx           = canvas.getContext('2d');
    const drawBtn       = document.getElementById('drawBtn');
    const undoDeleteBtn = document.getElementById('undoDeleteBtn');

    const resetBtn      = document.getElementById('resetBtn');
    const msg           = document.getElementById('msg');

    const undoBtn       = document.getElementById('undoBtn');
    const redoBtn       = document.getElementById('redoBtn');

    const contactInfo   = document.getElementById('contactInfo');
    const iconHint      = document.getElementById('iconHint');

    const dashedLines   = document.getElementById('dashedLines');
    const crossBlack    = document.getElementById('crossBlack');
    const crossRed      = document.getElementById('crossRed');
    const crossFSI      = document.getElementById('crossFSI');

    const gridOnly      = document.getElementById('gridOnly');
    const autoRefresh   = document.getElementById('autoRefresh');
    const autoRefreshBtn= document.getElementById('autoRefreshBtn');
    const imageOpacity  = document.getElementById('imageOpacity');
    const gridOpacity   = document.getElementById('gridOpacity');
    const codeOpacity   = document.getElementById('codeOpacity');
    const fillOpacityEl = document.getElementById('fillOpacity');

    const zoomRange     = document.getElementById('zoomRange');
    const zoomValue     = document.getElementById('zoomValue');
    const zoomNumber    = document.getElementById('zoomNumber');

    const borderColorEl = document.getElementById('borderColor');
    const textColorEl   = document.getElementById('textColor');
    const cellTextEl    = document.getElementById('cellText');
    const fillColorEl   = document.getElementById('fillColor');

    const gridTypeSelect   = document.getElementById('gridTypeSelect');
    const labelModeSelect  = document.getElementById('labelModeSelect');
    const legendModeSelect = document.getElementById('legendModeSelect');

    const themeToggle   = document.getElementById('themeToggle');
    const orientationToggle = document.getElementById('orientationToggle');
    const fullscreenToggle  = document.getElementById('fullscreenToggle');
    const briefingBtn   = document.getElementById('briefingBtn');
    const contactBtn    = document.getElementById('contactBtn');
    const optionsToggle = document.getElementById('optionsToggle');
    const root          = document.documentElement;

    const modeApplyBtn       = document.getElementById('modeApply');
    const modeEraseBorderBtn = document.getElementById('modeEraseBorder');
    const modeEraseCodeBtn   = document.getElementById('modeEraseCode');
    const modeMergeBtn       = document.getElementById('modeMerge');
    const modeSplitBtn       = document.getElementById('modeSplit');
    const modeResetBtn       = document.getElementById('modeReset');

    const loadScenarioBtn    = document.getElementById('loadScenarioBtn');
    const scenarioFileInput  = document.getElementById('scenarioFileInput');

    const helpBtn            = document.getElementById('helpBtn');
    const helpOverlay        = document.getElementById('helpOverlay');
    const closeHelpBtn       = document.getElementById('closeHelpBtn');

    const welcomeOverlay     = document.getElementById('welcomeOverlay');
    const closeWelcomeBtn    = document.getElementById('closeWelcomeBtn');

    const sheetSelect        = document.getElementById('sheetSelect');
    const addSheetBtn        = document.getElementById('addSheetBtn');
    const renameSheetBtn     = document.getElementById('renameSheetBtn');
    const duplicateSheet1Btn = document.getElementById('duplicateSheet1Btn');
    const deleteSheetBtn     = document.getElementById('deleteSheetBtn');

    const mapsAddress        = document.getElementById('mapsAddress');
    const mapsOpenBtn        = document.getElementById('mapsOpenBtn');

    const exportMenuBtn      = document.getElementById('exportMenuBtn');
    const exportMenu         = document.getElementById('exportMenu');
    const exportPngBtn       = document.getElementById('exportPngBtn');
    const exportPdfBtn       = document.getElementById('exportPdfBtn');
    const exportGridOnlyBtn  = document.getElementById('exportGridOnlyBtn');
    const exportPrintBtn     = document.getElementById('exportPrintBtn');
    const exportMailBtn      = document.getElementById('exportMailBtn');
    const exportWhatsappBtn  = document.getElementById('exportWhatsappBtn');

    const fillHelpIcon       = document.getElementById('fillHelpIcon');
    const fillHelpTooltip    = document.getElementById('fillHelpTooltip');
    const zoneHelpWrapper    = document.getElementById('zoneHelpWrapper');

    let selectionAction = "apply";

    let img = null;

    const MARGIN_LEFT = 40;
    const MARGIN_TOP  = 40;

    let selectedCells = {};
    let lastGridGeom  = null;

    let mergedRegions = [];
    let nextRegionId = 1;
    let currentRegionId = null;

    let history = [];
    let historyIndex = -1;

    let orientationMode = "portrait"; // rotation interne (0¬∞ / 90¬∞)
    let briefingMode = false;

    let baseCanvasWidth = 0;
    let baseCanvasHeight = 0;

    // Feuilles : sc√©nario + imageData
    let sheets = [];
    let currentSheetIndex = 0;

    // Pour les raccourcis Ctrl+C / Ctrl+V / Delete
    let lastClickedCell = null;
    let copiedCellStyle = null;

    // ====== D√âTECTION MOBILE / DESKTOP ======
    function isMobileDevice() {
      const ua = (navigator.userAgent || navigator.vendor || window.opera || "").toLowerCase();
      return /android|iphone|ipad|ipod|windows phone|blackberry|opera mini|mobile/.test(ua);
    }

    function setMsg(text) {
      msg.textContent = text || "";
    }

    function indexToLetters(index) {
      index = Math.floor(index);
      let s = "";
      while (index >= 0) {
        s = String.fromCharCode(65 + (index % 26)) + s;
        index = Math.floor(index / 26) - 1;
      }
      return s;
    }

    function getLegendMode() {
      return legendModeSelect.value || "full";
    }

    function handleCrossChange(changed) {
      if (changed.checked) {
        if (changed !== crossBlack) crossBlack.checked = false;
        if (changed !== crossRed)   crossRed.checked   = false;
        if (changed !== crossFSI)   crossFSI.checked   = false;
      }
    }

    crossBlack.addEventListener('change', () => { handleCrossChange(crossBlack); autoRedrawIfEnabled(); });
    crossRed.addEventListener('change',   () => { handleCrossChange(crossRed);   autoRedrawIfEnabled(); });
    crossFSI.addEventListener('change',   () => { handleCrossChange(crossFSI);   autoRedrawIfEnabled(); });

    function updateThemeButton() {
      const current = root.getAttribute('data-theme') || 'dark';
      const iconSpan = themeToggle.querySelector('.theme-toggle-icon');
      iconSpan.textContent = current === 'dark' ? '‚òØ' : '‚òº';
    }

    themeToggle.addEventListener('click', () => {
      const current = root.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      root.setAttribute('data-theme', next);
      updateThemeButton();
    });

    updateThemeButton();

    // Ic√¥ne portrait/paysage bas√©e sur la forme r√©elle du canvas
    function updateOrientationButton() {
      const iconSpan = orientationToggle.querySelector('.orient-icon');
      if (!iconSpan) return;

      let isLandscape = true;
      if (canvas.width && canvas.height) {
        isLandscape = canvas.width >= canvas.height;
      }

      if (isLandscape) {
        iconSpan.classList.remove('orient-portrait');
        iconSpan.classList.add('orient-landscape');
        orientationToggle.title = "Affichage actuel : paysage (clique pour passer en portrait)";
      } else {
        iconSpan.classList.remove('orient-landscape');
        iconSpan.classList.add('orient-portrait');
        orientationToggle.title = "Affichage actuel : portrait (clique pour passer en paysage)";
      }
    }

    orientationToggle.addEventListener('click', () => {
      orientationMode = (orientationMode === "portrait") ? "landscape" : "portrait";
      if (img || gridOnly.checked) {
        drawGrid();
      } else {
        setMsg("Choisis une image ou active \"Grille sans image\" puis clique sur APPLIQUER.");
      }
    });

    fullscreenToggle.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      } else {
        document.exitFullscreen().catch(() => {});
      }
    });

    function setIconHint(text) {
      iconHint.textContent = text || "";
    }

    function addIconHint(btn, text) {
      if (!btn) return;
      btn.addEventListener('mouseenter', () => setIconHint(text));
      btn.addEventListener('mouseleave', () => setIconHint(""));
    }

    addIconHint(themeToggle,      "Basculer entre mode sombre et mode clair");
    addIconHint(orientationToggle,"Portrait / Paysage (affichage uniquement, rotation de la carte)");
    addIconHint(fullscreenToggle, "Basculer en mode plein √©cran");
    addIconHint(briefingBtn,      "Mode briefing : la carte est mise en avant, les options sont masqu√©es.");
    addIconHint(loadScenarioBtn,  "Charger un sc√©nario QuadRico (.json)");
    addIconHint(helpBtn,          "Afficher le guide d√©taill√© QuadRico");
    addIconHint(resetBtn,         "R√©initialiser tous les r√©glages et effacer la grille");
    addIconHint(optionsToggle,    "Afficher / masquer le bloc options (mode mobile)");
    addIconHint(autoRefreshBtn,   "Rafra√Æchissement auto : la carte se met √† jour d√®s que tu modifies un param√®tre g√©n√©ral.");
    addIconHint(exportMenuBtn,    "Exporter / imprimer (PNG, PDF, quadrillage, mail, WhatsApp, sc√©nario)");

    // Bouton de contact (client mail adapt√© desktop / mobile)
    contactBtn.addEventListener('mouseenter', () => {
      setIconHint("Envoyer un mail au concepteur de QuadRico");
      contactInfo.textContent =
        "Pour toutes questions, remarques ou demandes d'am√©lioration, contacter par mail : eric.marchetti@gendarmerie.interieur.gouv.fr";
    });
    contactBtn.addEventListener('mouseleave', () => {
      setIconHint("");
      contactInfo.textContent = "";
    });
    contactBtn.addEventListener('click', () => {
      const to = "eric.marchetti@gendarmerie.interieur.gouv.fr";
      const subjectEnc = encodeURIComponent("QuadRico - remarques / am√©liorations");
      const bodyEnc = encodeURIComponent(
        "Bonjour,\n\nJe vous contacte au sujet de l'outil QuadRico pour vous faire part de questions, remarques ou demandes d'am√©lioration.\n\nCordialement,\n"
      );

      if (isMobileDevice()) {
        // Sur t√©l√©phone / tablette : application mail par d√©faut
        const mailtoUrl =
          "mailto:" + encodeURIComponent(to) +
          "?subject=" + subjectEnc +
          "&body=" + bodyEnc;
        window.location.href = mailtoUrl;
      } else {
        // Sur ordinateur : Gmail Web (ou handler configur√© pour ce type de lien)
        const url =
          "https://mail.google.com/mail/u/0/?view=cm&fs=1" +
          "&to=" + encodeURIComponent(to) +
          "&su=" + subjectEnc +
          "&body=" + bodyEnc;
        window.open(url, "_blank");
      }
    });

    briefingBtn.addEventListener('click', () => {
      briefingMode = !briefingMode;
      document.body.classList.toggle('briefing-mode', briefingMode);

      if (briefingMode && baseCanvasWidth && baseCanvasHeight) {
        const availW = window.innerWidth - 40;
        const availH = window.innerHeight - 160;
        let scale = Math.min(availW / baseCanvasWidth, availH / baseCanvasHeight);
        scale = Math.max(0.5, Math.min(scale, 3));
        zoomRange.value = Math.round(scale * 100);
        zoomNumber.value = zoomRange.value;
        applyZoomScale();
        setIconHint("Mode briefing : vue g√©n√©rale de la carte.");
      } else {
        zoomRange.value = 100;
        zoomNumber.value = 100;
        applyZoomScale();
        setIconHint("Mode normal : r√©glages r√©affich√©s.");
      }
    });

    optionsToggle.addEventListener('click', () => {
      document.body.classList.toggle('options-collapsed');
    });

    function initOptionsCollapsedOnLoad() {
      if (window.innerWidth <= 900) {
        document.body.classList.add('options-collapsed');
      } else {
        document.body.classList.remove('options-collapsed');
      }
    }

    function updateMobileOrientationClasses() {
      document.body.classList.remove('mobile-portrait', 'mobile-landscape');
      if (window.innerWidth <= 900) {
        if (window.innerHeight >= window.innerWidth) {
          document.body.classList.add('mobile-portrait');
        } else {
          document.body.classList.add('mobile-landscape');
        }
      }
    }

    window.addEventListener('resize', () => {
      if (window.innerWidth > 900) {
        document.body.classList.remove('options-collapsed');
      }
      updateMobileOrientationClasses();
    });

    window.addEventListener('orientationchange', () => {
      updateMobileOrientationClasses();
    });

    initOptionsCollapsedOnLoad();
    updateMobileOrientationClasses();

    // Chargement d'image + stockage dans la feuille
    imageLoader.addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) {
        setMsg("Aucun fichier s√©lectionn√©.");
        return;
      }

      const reader = new FileReader();
      reader.onload = function (ev) {
        const dataUrl = ev.target.result;
        const image = new Image();
        image.onload = function () {
          img = image;
          gridOnly.checked = false;
          setMsg("Image charg√©e. Clique sur \"APPLIQUER\".");
          if (sheets[currentSheetIndex]) {
            sheets[currentSheetIndex].imageData = dataUrl;
          }
          drawBase();
          if (autoRefresh.checked) {
            drawGrid();
          }
        };
        image.onerror = function () {
          setMsg("Erreur lors du chargement de l'image.");
        };
        image.src = dataUrl;
      };
      reader.readAsDataURL(file);
    });

    function getGridType() {
      return gridTypeSelect.value || "fsi";
    }

    function getLabelMode() {
      return labelModeSelect.value || "none";
    }

    function getCrossMode() {
      if (crossBlack.checked) return "black";
      if (crossRed.checked)   return "red";
      if (crossFSI.checked)   return "fsi";
      return "none";
    }

    function getBorderWidthPx() {
      const r = document.querySelector('input[name="borderWidth"]:checked');
      const v = r ? r.value : "normal";
      if (v === "epais") return 3;
      if (v === "tres-epais") return 5;
      return 1.5; // m√™me √©paisseur que le quadrillage de base
    }

    function applyZoomScale() {
      if (!baseCanvasWidth || !baseCanvasHeight) return;
      const zoom = parseInt(zoomRange.value, 10);
      const scale = zoom / 100;
      const scrollContainer = document.querySelector('.canvas-scroll');
      const isMobile = window.innerWidth < 900;

      zoomValue.textContent = zoom + "%";
      if (zoomNumber) zoomNumber.value = zoom;

      if (isMobile && zoom <= 100) {
        canvas.style.width  = "";
        canvas.style.height = "";
      } else {
        canvas.style.width  = (baseCanvasWidth * scale) + "px";
        canvas.style.height = (baseCanvasHeight * scale) + "px";
      }

      if (scrollContainer) {
        if (zoom >= 113) {
          scrollContainer.style.maxHeight = '80vh';
          scrollContainer.style.overflow = 'auto';
        } else {
          scrollContainer.style.maxHeight = '';
          scrollContainer.style.overflow = 'visible';
        }
      }
    }

    function drawBase() {
      const cols = parseInt(document.getElementById('cols').value, 10) || 10;
      const rows = parseInt(document.getElementById('rows').value, 10) || 10;
      const useGridOnly = gridOnly.checked;

      let imgW, imgH;

      if (useGridOnly || !img) {
        const cellSize = 40;
        imgW = cols * cellSize;
        imgH = rows * cellSize;
      } else {
        imgW = img.width;
        imgH = img.height;
      }

      const cellW = imgW / cols;
      const cellH = imgH / rows;
      const totalW = imgW + 2 * MARGIN_LEFT;
      const totalH = imgH + 2 * MARGIN_TOP;

      if (orientationMode === "portrait") {
        canvas.width  = totalW;
        canvas.height = totalH;
      } else {
        canvas.width  = totalH;
        canvas.height = totalW;
      }

      baseCanvasWidth = canvas.width;
      baseCanvasHeight = canvas.height;
      applyZoomScale();
      updateOrientationButton();

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (orientationMode === "landscape") {
        // Rotation 90¬∞ sens horaire : (x', y') = (y, -x + totalW)
        ctx.setTransform(0, -1, 1, 0, 0, totalW);
      }

      if (!useGridOnly) {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, totalW, totalH);
      }

      const imgAlpha = parseInt(imageOpacity.value, 10) / 100;

      if (!useGridOnly && img) {
        ctx.save();
        ctx.globalAlpha = imgAlpha;
        ctx.drawImage(img, MARGIN_LEFT, MARGIN_TOP);
        ctx.restore();
      }

      lastGridGeom = { cols, rows, cellW, cellH, imgW, imgH, totalW, totalH };
    }

    /* Couleur de base du quadrillage pour une case (pour bordure = (n√©ant)) */
    function getGridBaseColorForCell(c, r) {
      if (!lastGridGeom) return "#000000";
      const { cols, rows } = lastGridGeom;
      const gridType = getGridType();
      const midCol = cols / 2;
      const midRow = rows / 2;
      const colorTL = 'yellow';
      const colorTR = 'blue';
      const colorBR = 'green';
      const colorBL = 'red';

      if (gridType === "fsi") {
        if (c < midCol && r < midRow)       return colorTL;
        if (c >= midCol && r < midRow)      return colorTR;
        if (c >= midCol && r >= midRow)     return colorBR;
        return colorBL;
      }
      if (gridType === "uni-red")   return "red";
      if (gridType === "uni-black") return "black";
      return "#000000";
    }

    function findRegionByCell(c, r) {
      for (const region of mergedRegions) {
        if (region.cells.some(cell => cell.c === c && cell.r === r)) {
          return region;
        }
      }
      return null;
    }

    function drawZoneFills() {
      if (!lastGridGeom) return;
      const { cols, rows, cellW, cellH } = lastGridGeom;

      ctx.save();

      // Zones individuelles (chaque case a son opacit√©)
      for (const key in selectedCells) {
        const sel = selectedCells[key];
        if (!sel.fillColor) continue;

        const [cStr, rStr] = key.split(",");
        const c = parseInt(cStr, 10);
        const r = parseInt(rStr, 10);
        if (isNaN(c) || isNaN(r)) continue;
        if (c < 0 || c >= cols || r < 0 || r >= rows) continue;

        const xCell = MARGIN_LEFT + c * cellW;
        const yCell = MARGIN_TOP  + r * cellH;
        const alpha = typeof sel.fillAlpha === "number" ? sel.fillAlpha : 0.35;

        ctx.globalAlpha = alpha;
        ctx.fillStyle = sel.fillColor;
        ctx.fillRect(xCell, yCell, cellW, cellH);
      }

      ctx.restore();
    }

    function drawGrid() {
      const cols = parseInt(document.getElementById('cols').value, 10);
      const rows = parseInt(document.getElementById('rows').value, 10);

      if (!cols || !rows || cols < 1 || rows < 1) {
        setMsg("Colonnes / lignes invalides.");
        return;
      }

      const gridType    = getGridType();
      const labelMode   = getLabelMode();
      const useDashed   = dashedLines.checked;
      const crossMode   = getCrossMode();
      const useGridOnly = gridOnly.checked;
      const legendMode  = getLegendMode();

      if (!useGridOnly && !img) {
        setMsg("Charge d'abord une image ou active \"Grille sans image\".");
        return;
      }

      drawBase();
      drawZoneFills();
      updateOrientationButton();

      if (!lastGridGeom) return;

      const { cellW, cellH, imgW, imgH, cols: C, rows: R } = lastGridGeom;

      const midCol = C / 2;
      const midRow = R / 2;

      const colorTL = 'yellow';
      const colorTR = 'blue';
      const colorBR = 'green';
      const colorBL = 'red';

      const gridAlpha = parseInt(gridOpacity.value, 10) / 100;
      const codeAlpha = parseInt(codeOpacity.value, 10) / 100;

      function isNoGridCell(c, r) {
        const key = `${c},${r}`;
        const sel = selectedCells[key];
        return sel && sel.noGrid;
      }

      function edgeSuppressedVertical(c, r) {
        const leftNo  = (c - 1 >= 0) ? isNoGridCell(c - 1, r) : false;
        const rightNo = (c < C)      ? isNoGridCell(c, r)     : false;
        if (leftNo || rightNo) return true;

        if (c - 1 >= 0 && c < C) {
          const regL = findRegionByCell(c - 1, r);
          const regR = findRegionByCell(c, r);
          if (regL && regR && regL.id === regR.id) return true;
        }
        return false;
      }

      function edgeSuppressedHorizontal(c, r) {
        const topNo    = (r - 1 >= 0) ? isNoGridCell(c, r - 1) : false;
        const bottomNo = (r < R)      ? isNoGridCell(c, r)     : false;
        if (topNo || bottomNo) return true;

        if (r - 1 >= 0 && r < R) {
          const regT = findRegionByCell(c, r - 1);
          const regB = findRegionByCell(c, r);
          if (regT && regB && regT.id === regB.id) return true;
        }
        return false;
      }

      ctx.lineWidth = 1.5;

      if (useDashed && gridType !== "none") {
        ctx.setLineDash([20, 10]);
      } else {
        ctx.setLineDash([]);
      }

      if (gridType !== "none") {
        ctx.save();
        ctx.globalAlpha = gridAlpha;

        for (let c = 0; c <= C; c++) {
          const x = MARGIN_LEFT + c * cellW;
          for (let r = 0; r < R; r++) {
            if (edgeSuppressedVertical(c, r)) continue;

            const y1 = MARGIN_TOP + r * cellH;
            const y2 = MARGIN_TOP + (r + 1) * cellH;

            const colIndex = Math.min(c === C ? c - 1 : c, C - 1);
            const color = (gridType === "fsi")
              ? ((colIndex < midCol && r < midRow)       ? colorTL
                : (colIndex >= midCol && r < midRow)     ? colorTR
                : (colIndex >= midCol && r >= midRow)    ? colorBR
                :                                          colorBL)
              : (gridType === "uni-red" ? "red"
                : gridType === "uni-black" ? "black"
                : "black");

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }
        }

        for (let r = 0; r <= R; r++) {
          const y = MARGIN_TOP + r * cellH;
          for (let c = 0; c < C; c++) {
            if (edgeSuppressedHorizontal(c, r)) continue;

            const x1 = MARGIN_LEFT + c * cellW;
            const x2 = MARGIN_LEFT + (c + 1) * cellW;

            const rowIndex = Math.min(r === R ? r - 1 : r, R - 1);
            const color = (gridType === "fsi")
              ? ((c < midCol && rowIndex < midRow)       ? colorTL
                : (c >= midCol && rowIndex < midRow)     ? colorTR
                : (c >= midCol && rowIndex >= midRow)    ? colorBR
                :                                          colorBL)
              : (gridType === "uni-red" ? "red"
                : gridType === "uni-black" ? "black"
                : "black");

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.stroke();
          }
        }

        ctx.restore();
      }

      if (legendMode !== "none") {
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.fillStyle = useGridOnly ? "#ffffff" : "black";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        if (legendMode === "partial" || legendMode === "full") {
          for (let c = 0; c < C; c++) {
            const label = indexToLetters(c);
            ctx.fillText(label, MARGIN_LEFT + (c + 0.5) * cellW, MARGIN_TOP / 2);
          }

          ctx.textAlign = "right";
          for (let r = 0; r < R; r++) {
            ctx.fillText((r + 1), MARGIN_LEFT - 5, MARGIN_TOP + (r + 0.5) * cellH);
          }
        }

        if (legendMode === "full") {
          ctx.textAlign = "center";
          const bottomY = MARGIN_TOP + imgH + MARGIN_TOP / 2;
          for (let c = 0; c < C; c++) {
            const label = indexToLetters(c);
            ctx.fillText(label, MARGIN_LEFT + (c + 0.5) * cellW, bottomY);
          }

          ctx.textAlign = "left";
          const rightX = MARGIN_LEFT + imgW + 5;
          for (let r = 0; r < R; r++) {
            ctx.fillText((r + 1), rightX, MARGIN_TOP + (r + 0.5) * cellH);
          }
        }
      }

      if (crossMode !== "none") {
        ctx.lineWidth = 1.2;
        ctx.setLineDash([]);
        ctx.globalAlpha = codeAlpha;

        for (let r = 0; r < R; r++) {
          for (let c = 0; c < C; c++) {
            const key = `${c},${r}`;
            const sel = selectedCells[key];
            if (sel && ((sel.text && sel.text.length > 0) || sel.noCode)) continue;

            const regionHere = findRegionByCell(c, r);
            if (regionHere && regionHere.text && regionHere.text.length > 0) continue;

            let color = "black";
            if (crossMode === "black") {
              color = "black";
            } else if (crossMode === "red") {
              color = "red";
            } else if (crossMode === "fsi") {
              if (c < midCol && r < midRow)       color = colorTL;
              else if (c >= midCol && r < midRow) color = colorTR;
              else if (c >= midCol && r >= midRow)color = colorBR;
              else                                color = colorBL;
            }

            ctx.strokeStyle = color;
            const x = MARGIN_LEFT + (c + 0.5) * cellW;
            const y = MARGIN_TOP  + (r + 0.5) * cellH;
            const s = Math.max(3, Math.min(cellW, cellH) * 0.15);

            ctx.beginPath();
            ctx.moveTo(x - s, y - s);
            ctx.lineTo(x + s, y + s);
            ctx.moveTo(x - s, y + s);
            ctx.lineTo(x + s, y - s);
            ctx.stroke();
          }
        }
      }

      if (labelMode !== "none") {
        ctx.setLineDash([]);
        ctx.globalAlpha = codeAlpha;

        const midColLabel = C / 2;
        const midRowLabel = R / 2;

        for (let r = 0; r < R; r++) {
          for (let c = 0; c < C; c++) {
            const key = `${c},${r}`;
            const sel = selectedCells[key];
            if (sel && ((sel.text && sel.text.length > 0) || sel.noCode)) continue;

            const regionHere = findRegionByCell(c, r);
            if (regionHere && regionHere.text && regionHere.text.length > 0) continue;

            const label = indexToLetters(c) + (r + 1);
            let textColor = "black";

            if (labelMode === "color") {
              textColor = "red";
            } else if (labelMode === "fsi-color") {
              if (c < midColLabel && r < midRowLabel)       textColor = colorTL;
              else if (c >= midColLabel && r < midRowLabel) textColor = colorTR;
              else if (c >= midColLabel && r >= midRowLabel)textColor = colorBR;
              else                                          textColor = colorBL;
            } else if (labelMode === "uni") {
              textColor = "black";
            }

            ctx.fillStyle = textColor;

            const x = MARGIN_LEFT + (c + 0.5) * cellW;
            const y = MARGIN_TOP  + (r + 0.5) * cellH;
            const padding = Math.min(cellW, cellH) * 0.1;
            const maxWidth = cellW - 2 * padding;
            const maxHeight = cellH - 2 * padding;
            let fontSize = cellH * 0.45;
            if (fontSize < 6) fontSize = 6;

            ctx.font = fontSize + "px sans-serif";
            let metrics = ctx.measureText(label);
            while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
              fontSize -= 1;
              ctx.font = fontSize + "px sans-serif";
              metrics = ctx.measureText(label);
            }

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(label, x, y);
          }
        }
      }

      ctx.setLineDash([]);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // Cases individuelles (bordures / textes ‚Äì hors r√©gions)
      for (const key in selectedCells) {
        const [cStr, rStr] = key.split(",");
        const c = parseInt(cStr, 10);
        const r = parseInt(rStr, 10);
        if (isNaN(c) || isNaN(r)) continue;
        if (!lastGridGeom) continue;
        const { cols: C2, rows: R2, cellW, cellH } = lastGridGeom;
        if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;

        const regionHere = findRegionByCell(c, r);
        if (regionHere) continue;

        const sel = selectedCells[key];
        const { borderColor, borderWidth, text, textColor, alpha } = sel;

        const xCell = MARGIN_LEFT + c * cellW;
        const yCell = MARGIN_TOP  + r * cellH;
        const a = typeof alpha === "number" ? alpha : 1.0;
        ctx.globalAlpha = a;

        if (borderWidth && borderColor) {
          ctx.lineWidth = borderWidth;
          ctx.strokeStyle = borderColor;
          ctx.strokeRect(xCell, yCell, cellW, cellH);
        }

        if (text && text.length > 0) {
          const drawColor = textColor || borderColor || "#000000";
          ctx.fillStyle = drawColor;

          let fontSize = cellH * 0.45;
          if (fontSize < 6) fontSize = 6;
          ctx.font = fontSize + "px sans-serif";

          const padding = Math.min(cellW, cellH) * 0.1;
          const maxWidth = cellW - 2 * padding;
          const maxHeight = cellH - 2 * padding;
          let metrics = ctx.measureText(text);

          while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
            fontSize -= 1;
            ctx.font = fontSize + "px sans-serif";
            metrics = ctx.measureText(text);
          }

          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            text,
            MARGIN_LEFT + (c + 0.5) * cellW,
            MARGIN_TOP  + (r + 0.5) * cellH
          );
        }
      }

      ctx.globalAlpha = 1;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      function regionHasCell(region, c, r) {
        return region.cells.some(cell => cell.c === c && cell.r === r);
      }

      // R√©gions fusionn√©es (bordures / texte, mais remplissage toujours par case)
      for (const region of mergedRegions) {
        if (!region.cells || !region.cells.length) continue;
        const { cols: C2, rows: R2, cellW, cellH } = lastGridGeom;

        let minC = Infinity, maxC = -1, minR = Infinity, maxR = -1;
        for (const cell of region.cells) {
          const c = cell.c;
          const r = cell.r;
          if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;
          if (c < minC) minC = c;
          if (c > maxC) maxC = c;
          if (r < minR) minR = r;
          if (r > maxR) maxR = r;
        }
        if (minC === Infinity || minR === Infinity) continue;

        const x = MARGIN_LEFT + minC * cellW;
        const y = MARGIN_TOP  + minR * cellH;
        const w = (maxC - minC + 1) * cellW;
        const h = (maxR - minR + 1) * cellH;

        const alpha = typeof region.alpha === "number" ? region.alpha : 1.0;

        if (region.borderColor && region.borderWidth) {
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.lineWidth = region.borderWidth;
          ctx.strokeStyle = region.borderColor;
          ctx.setLineDash([]);

          for (const cell of region.cells) {
            const c = cell.c;
            const r = cell.r;
            if (c < 0 || c >= C2 || r < 0 || r >= R2) continue;

            const x0 = MARGIN_LEFT + c * cellW;
            const y0 = MARGIN_TOP  + r * cellH;
            const x1 = x0 + cellW;
            const y1 = y0 + cellH;

            if (!regionHasCell(region, c, r - 1)) {
              ctx.beginPath();
              ctx.moveTo(x0, y0);
              ctx.lineTo(x1, y0);
              ctx.stroke();
            }
            if (!regionHasCell(region, c, r + 1)) {
              ctx.beginPath();
              ctx.moveTo(x0, y1);
              ctx.lineTo(x1, y1);
              ctx.stroke();
            }
            if (!regionHasCell(region, c - 1, r)) {
              ctx.beginPath();
              ctx.moveTo(x0, y0);
              ctx.lineTo(x0, y1);
              ctx.stroke();
            }
            if (!regionHasCell(region, c + 1, r)) {
              ctx.beginPath();
              ctx.moveTo(x1, y0);
              ctx.lineTo(x1, y1);
              ctx.stroke();
            }
          }

          ctx.restore();
        }

        if (region.text && region.text.length > 0) {
          const txtColor = region.textColor || region.borderColor || "#ffffff";

          ctx.save();
          ctx.globalAlpha = alpha;

          ctx.beginPath();
          for (const cell of region.cells) {
            const cx = MARGIN_LEFT + cell.c * cellW;
            const cy = MARGIN_TOP  + cell.r * cellH;
            ctx.rect(cx, cy, cellW, cellH);
          }
          ctx.clip();

          const padding = Math.min(w, h) * 0.1;
          const maxWidth = w - 2 * padding;
          const maxHeight = h - 2 * padding;
          let fontSize = h * 0.45;
          if (fontSize < 6) fontSize = 6;

          ctx.font = fontSize + "px sans-serif";
          let metrics = ctx.measureText(region.text);

          while ((metrics.width > maxWidth || fontSize > maxHeight) && fontSize > 6) {
            fontSize -= 1;
            ctx.font = fontSize + "px sans-serif";
            metrics = ctx.measureText(region.text);
          }

          ctx.fillStyle = txtColor;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const centerX = x + w / 2;
          const centerY = y + h / 2;
          ctx.fillText(region.text, centerX, centerY);

          ctx.restore();
        }
      }

      ctx.globalAlpha = 1;
      setMsg("Quadrillage appliqu√©. Tu peux exporter ou imprimer l'image depuis le menu üì§.");

      if (sheets.length) {
        sheets[currentSheetIndex].scenario = buildScenario();
        refreshSheetSelect();
      }
    }

    drawBtn.addEventListener('click', drawGrid);

    function setSelectionAction(action) {
      selectionAction = action;
      [modeApplyBtn, modeEraseBorderBtn, modeEraseCodeBtn, modeMergeBtn, modeSplitBtn, modeResetBtn]
        .forEach(btn => btn.classList.remove('active'));
      if (action === "apply") modeApplyBtn.classList.add('active');
      if (action === "eraseBorder") modeEraseBorderBtn.classList.add('active');
      if (action === "eraseCode") modeEraseCodeBtn.classList.add('active');
      if (action === "merge") modeMergeBtn.classList.add('active');
      if (action === "split") modeSplitBtn.classList.add('active');
      if (action === "reset") modeResetBtn.classList.add('active');
    }

    modeApplyBtn.addEventListener('click', () => setSelectionAction("apply"));
    modeEraseBorderBtn.addEventListener('click', () => setSelectionAction("eraseBorder"));
    modeEraseCodeBtn.addEventListener('click', () => setSelectionAction("eraseCode"));
    modeMergeBtn.addEventListener('click', () => setSelectionAction("merge"));
    modeSplitBtn.addEventListener('click', () => setSelectionAction("split"));
    modeResetBtn.addEventListener('click', () => setSelectionAction("reset"));

    function pushHistory() {
      const snapshot = structuredClone({
        selectedCells,
        mergedRegions,
        currentRegionId
      });
      history = history.slice(0, historyIndex + 1);
      history.push(snapshot);
      historyIndex = history.length - 1;
    }

    function restoreFromHistory() {
      if (historyIndex < 0 || historyIndex >= history.length) return;
      const snap = history[historyIndex];
      selectedCells = structuredClone(snap.selectedCells);
      mergedRegions  = structuredClone(snap.mergedRegions);
      currentRegionId = snap.currentRegionId;
      drawGrid();
    }

    function undoAction() {
      if (historyIndex > 0) {
        historyIndex--;
        restoreFromHistory();
        setMsg("Retour en arri√®re.");
      } else {
        setMsg("Aucune action √† annuler.");
      }
    }

    function redoAction() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreFromHistory();
        setMsg("Aucune action √† r√©tablir.");
      } else {
        setMsg("Aucune action √† r√©tablir.");
      }
    }

    undoBtn.addEventListener('click', undoAction);
    redoBtn.addEventListener('click', redoAction);

    function resetCell(c, r) {
      const key = `${c},${r}`;
      const regionHere = findRegionByCell(c, r);
      if (regionHere) {
        regionHere.cells = regionHere.cells.filter(cell => !(cell.c === c && cell.r === r));
        if (regionHere.cells.length === 0) {
          const regionIndex = mergedRegions.findIndex(rg => rg.id === regionHere.id);
          if (regionIndex >= 0) {
            mergedRegions.splice(regionIndex, 1);
          }
          if (currentRegionId === regionHere.id) {
            currentRegionId = null;
          }
        }
      }
      delete selectedCells[key];
    }

    canvas.addEventListener('click', (e) => {
      if (!lastGridGeom) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const xPix = (e.clientX - rect.left) * scaleX;
      const yPix = (e.clientY - rect.top) * scaleY;

      let x = xPix;
      let y = yPix;

      if (orientationMode === "landscape" && lastGridGeom) {
        const { totalW } = lastGridGeom;
        const xLogical = totalW - yPix;
        const yLogical = xPix;
        x = xLogical;
        y = yLogical;
      }

      const { cols, rows, cellW, cellH, imgW, imgH } = lastGridGeom;

      if (x < MARGIN_LEFT || x > MARGIN_LEFT + imgW ||
          y < MARGIN_TOP  || y > MARGIN_TOP  + imgH) {
        return;
      }

      const c = Math.floor((x - MARGIN_LEFT) / cellW);
      const r = Math.floor((y - MARGIN_TOP)  / cellH);
      if (c < 0 || c >= cols || r < 0 || r >= rows) return;

      const key = `${c},${r}`;
      let regionHere = findRegionByCell(c, r);

      lastClickedCell = { c, r };

      if (selectionAction === "merge" && regionHere) {
        currentRegionId = regionHere.id;
      }

      pushHistory();

      const fillValue = fillColorEl.value; // "none" ou couleur rgba(...)
      const fillAlpha = parseInt(fillOpacityEl.value || "35", 10) / 100;

      if (selectionAction === "apply") {
        const borderChoice = borderColorEl.value; // "none" ou couleur
        const borderWidth = getBorderWidthPx();
        const text = cellTextEl.value.trim();
        const txtColor = textColorEl.value || "";
        const alpha = 1.0;

        let effectiveBorderColor;
        if (borderChoice === "none") {
          effectiveBorderColor = getGridBaseColorForCell(c, r);
        } else {
          effectiveBorderColor = borderChoice;
        }

        // Mise √† jour du bloc fusionn√© (bordure / texte uniquement)
        if (regionHere) {
          regionHere.borderColor = effectiveBorderColor;
          regionHere.borderWidth = borderWidth;
          regionHere.text        = text;
          regionHere.textColor   = txtColor;
          regionHere.alpha       = alpha;
        }

        // Couleur / opacit√© de zone et style appliqu√©s √† la case cliqu√©e
        const existing = selectedCells[key] || {};

        let newFillColor = (typeof existing.fillColor !== "undefined") ? existing.fillColor : null;
        let newFillAlpha = (typeof existing.fillAlpha === "number") ? existing.fillAlpha : null;

        if (fillValue === "none") {
          newFillColor = null;
          newFillAlpha = null;
        } else {
          newFillColor = fillValue;
          newFillAlpha = fillAlpha;
        }

        selectedCells[key] = {
          ...existing,
          borderColor: effectiveBorderColor,
          borderWidth: borderWidth,
          text,
          textColor: txtColor,
          noCode: text.length > 0,
          noGrid: false,
          alpha,
          fillColor: newFillColor,
          fillAlpha: newFillAlpha
        };
      } else if (selectionAction === "eraseBorder") {
        if (regionHere) {
          for (const cell of regionHere.cells) {
            const k = `${cell.c},${cell.r}`;
            const cSel = selectedCells[k] || {};
            delete cSel.borderColor;
            delete cSel.borderWidth;
            cSel.noGrid = true;
            selectedCells[k] = cSel;
          }
          regionHere.borderColor = null;
          regionHere.borderWidth = null;
        } else {
          const cell = selectedCells[key] || {};
          delete cell.borderColor;
          delete cell.borderWidth;
          cell.noGrid = true;
          selectedCells[key] = cell;
        }
      } else if (selectionAction === "eraseCode") {
        if (regionHere) {
          for (const cell of regionHere.cells) {
            const k = `${cell.c},${cell.r}`;
            const cSel = selectedCells[k] || {};
            cSel.noCode = true;
            cSel.text   = "";
            selectedCells[k] = cSel;
          }
          regionHere.text = "";
        } else {
          const cell = selectedCells[key] || {};
          cell.noCode = true;
          cell.text = "";
          selectedCells[key] = cell;
        }
      } else if (selectionAction === "merge") {
        let region = regionHere;
        if (!region) {
          if (currentRegionId) {
            region = mergedRegions.find(rg => rg.id === currentRegionId);
            if (!region) {
              region = { id: nextRegionId++, cells: [], borderColor: null, borderWidth: null, text: "", textColor: "", alpha: 1, fillColor: null, fillAlpha: null };
              mergedRegions.push(region);
              currentRegionId = region.id;
            }
          } else {
            region = { id: nextRegionId++, cells: [], borderColor: null, borderWidth: null, text: "", textColor: "", alpha: 1, fillColor: null, fillAlpha: null };
            mergedRegions.push(region);
            currentRegionId = region.id;
          }
        } else {
          currentRegionId = region.id;
        }

        if (!region.cells.some(cell => cell.c === c && cell.r === r)) {
          region.cells.push({ c, r });
        }
      } else if (selectionAction === "split") {
        if (regionHere) {
          regionHere.cells = regionHere.cells.filter(cell => !(cell.c === c && cell.r === r));

          if (regionHere.cells.length === 0) {
            const regionIndex = mergedRegions.findIndex(rg => rg.id === regionHere.id);
            if (regionIndex >= 0) {
              mergedRegions.splice(regionIndex, 1);
            }
            if (currentRegionId === regionHere.id) {
              currentRegionId = null;
            }
          }
        } else {
          setMsg("Cette case n'est pas fusionn√©e, rien √† fractionner ici.");
        }
      } else if (selectionAction === "reset") {
        resetCell(c, r);
      }

      drawGrid();
    });

    undoDeleteBtn.addEventListener('click', () => {
      if (!lastGridGeom) {
        setMsg("Aucune grille appliqu√©e pour supprimer les modifications.");
        return;
      }
      selectedCells = {};
      mergedRegions = [];
      currentRegionId = null;
      nextRegionId = 1;
      pushHistory();
      drawGrid();
      setMsg("Toutes les modifications (bordures, textes, fusions, zones) ont √©t√© supprim√©es.");
    });

    function downloadPNG() {
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† exporter : applique un quadrillage d'abord.");
        return;
      }
      const link = document.createElement('a');
      link.href = canvas.toDataURL("image/png");
      link.download = "quadrico_carte.png";
      link.click();
      setMsg("Image PNG enregistr√©e (quadrico_carte.png).");
    }

    function printWithSize(pageSize) {
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† imprimer : applique un quadrillage d'abord.");
        return;
      }

      // Fonctionnement revenu comme avant : orientation coh√©rente avec la forme du canvas
      const orientation = canvas.width >= canvas.height ? "landscape" : "portrait";

      const dataUrl = canvas.toDataURL("image/png");
      const printWindow = window.open("", "_blank");
      if (!printWindow) {
        setMsg("Impossible d'ouvrir la fen√™tre d'impression (popup bloqu√©e ?).");
        return;
      }

      printWindow.document.write(`
        <html>
          <head>
            <title>QuadRico - Impression</title>
            <style>
              @page { size: ${pageSize} ${orientation}; margin: 5mm; }
              body {
                margin: 0;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
              }
              img {
                max-width: 100%;
                max-height: 100%;
                height: auto;
                display: block;
                margin: 0 auto;
              }
            </style>
          </head>
          <body>
            <img src="${dataUrl}" />
            <script>
              window.onload = function() {
                window.focus();
                window.print();
              };
            <\/script>
          </body>
        </html>
      `);
      printWindow.document.close();
    }

    resetBtn.addEventListener('click', function () {
      const ok = confirm("Tu veux vraiment tout effacer et r√©initialiser la grille ?");
      if (!ok) return;

      document.getElementById('cols').value = 10;
      document.getElementById('rows').value = 14;

      gridTypeSelect.value   = "fsi";
      legendModeSelect.value = "full";
      labelModeSelect.value  = "none";

      dashedLines.checked = false;
      crossBlack.checked  = false;
      crossRed.checked    = false;
      crossFSI.checked    = false;

      gridOnly.checked = false;
      autoRefresh.checked = false;
      updateAutoRefreshButton();

      imageOpacity.value = 100;
      gridOpacity.value = 100;
      codeOpacity.value = 100;
      fillOpacityEl.value = 35;

      zoomRange.value = 100;
      zoomNumber.value = 100;
      zoomValue.textContent = "100%";
      baseCanvasWidth = 0;
      baseCanvasHeight = 0;
      canvas.style.width  = "";
      canvas.style.height = "";

      setSelectionAction("apply");
      borderColorEl.value = "none";
      textColorEl.value = "";
      cellTextEl.value = "";
      fillColorEl.value = "none";

      selectedCells = {};
      mergedRegions = [];
      nextRegionId = 1;
      currentRegionId = null;
      history = [];
      historyIndex = -1;

      imageLoader.value = "";
      img = null;
      lastGridGeom = null;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      orientationMode = "portrait";
      updateOrientationButton();

      briefingMode = false;
      document.body.classList.remove('briefing-mode');

      lastClickedCell = null;
      copiedCellStyle = null;

      if (sheets.length) {
        sheets[currentSheetIndex].scenario = buildScenario();
        sheets[currentSheetIndex].imageData = null;
        refreshSheetSelect();
      }

      setMsg("R√©initialis√©. Charge une nouvelle image ou active \"Grille sans image\" pour recommencer.");
      initOptionsCollapsedOnLoad();
      updateMobileOrientationClasses();
    });

    zoomRange.addEventListener('input', () => {
      applyZoomScale();
    });

    zoomNumber.addEventListener('change', () => {
      let val = parseInt(zoomNumber.value, 10);
      if (isNaN(val)) val = 100;
      if (val < 50) val = 50;
      if (val > 300) val = 300;
      zoomNumber.value = val;
      zoomRange.value = val;
      applyZoomScale();
    });

    canvas.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        let val = parseInt(zoomRange.value, 10);
        if (isNaN(val)) val = 100;
        if (e.deltaY < 0) {
          val += 10;
        } else {
          val -= 10;
        }
        if (val < 50) val = 50;
        if (val > 300) val = 300;
        zoomRange.value = val;
        zoomNumber.value = val;
        applyZoomScale();
      }
    }, { passive: false });

    function autoRedrawIfEnabled() {
      if (!autoRefresh.checked) return;
      if (!img && !gridOnly.checked) {
        setMsg("Active \"Grille sans image\" ou charge une image, puis applique.");
        return;
      }
      drawGrid();
    }

    function updateAutoRefreshButton() {
      if (autoRefresh.checked) {
        autoRefreshBtn.classList.add('active');
        autoRefreshBtn.title = "Rafra√Æchissement auto activ√©";
      } else {
        autoRefreshBtn.classList.remove('active');
        autoRefreshBtn.title = "Rafra√Æchissement auto d√©sactiv√©";
      }
    }

    autoRefreshBtn.addEventListener('click', () => {
      autoRefresh.checked = !autoRefresh.checked;
      updateAutoRefreshButton();
      if (autoRefresh.checked) {
        if (img || gridOnly.checked) {
          drawGrid();
        } else {
          setMsg("Active \"Grille sans image\" ou charge une image.");
        }
      }
    });

    autoRefresh.addEventListener('change', () => {
      updateAutoRefreshButton();
      if (autoRefresh.checked) {
        if (img || gridOnly.checked) {
          drawGrid();
        } else {
          setMsg("Active \"Grille sans image\" ou charge une image.");
        }
      }
    });

    gridOnly.addEventListener('change', autoRedrawIfEnabled);
    document.getElementById('cols').addEventListener('change', autoRedrawIfEnabled);
    document.getElementById('rows').addEventListener('change', autoRedrawIfEnabled);

    legendModeSelect.addEventListener('change', autoRedrawIfEnabled);
    gridTypeSelect.addEventListener('change', autoRedrawIfEnabled);
    labelModeSelect.addEventListener('change', autoRedrawIfEnabled);

    imageOpacity.addEventListener('input', autoRedrawIfEnabled);
    gridOpacity.addEventListener('input', autoRedrawIfEnabled);
    codeOpacity.addEventListener('input', autoRedrawIfEnabled);
    dashedLines.addEventListener('change', autoRedrawIfEnabled);
    fillColorEl.addEventListener('change', autoRedrawIfEnabled);

    // Opacit√© zone : agit en direct sur la derni√®re case color√©e
    fillOpacityEl.addEventListener('input', () => {
      if (!lastClickedCell) return;
      const key = `${lastClickedCell.c},${lastClickedCell.r}`;
      const cell = selectedCells[key];
      if (!cell || !cell.fillColor) return;
      cell.fillAlpha = parseInt(fillOpacityEl.value || "35", 10) / 100;
      if (autoRefresh.checked) {
        autoRedrawIfEnabled();
      }
    });

    /* Infobulle pour Couleur de zone / S√©lection de case ‚Äì ic√¥ne "?" */
    let fillTooltipVisible = false;

    function showFillTooltip() {
      fillHelpTooltip.classList.remove('hidden');
      fillTooltipVisible = true;
    }

    function hideFillTooltip() {
      fillHelpTooltip.classList.add('hidden');
      fillTooltipVisible = false;
    }

    if (fillHelpIcon && fillHelpTooltip && zoneHelpWrapper) {
      // Desktop : affichage au survol de l'ic√¥ne
      fillHelpIcon.addEventListener('mouseenter', () => {
        if (window.innerWidth > 900) showFillTooltip();
      });
      fillHelpIcon.addEventListener('mouseleave', () => {
        if (window.innerWidth > 900) hideFillTooltip();
      });

      // Mobile : clic pour ouvrir / fermer
      fillHelpIcon.addEventListener('click', (e) => {
        if (window.innerWidth <= 900) {
          e.stopPropagation();
          if (fillTooltipVisible) {
            hideFillTooltip();
          } else {
            showFillTooltip();
          }
        }
      });

      document.addEventListener('click', (e) => {
        if (window.innerWidth <= 900 && !zoneHelpWrapper.contains(e.target)) {
          hideFillTooltip();
        }
      });
    }

    /* ==== SAUVEGARDE / CHARGEMENT SC√âNARIO ==== */

    function buildScenario() {
      const colsVal = document.getElementById('cols').value;
      const rowsVal = document.getElementById('rows').value;
      const borderWidthRadio = document.querySelector('input[name="borderWidth"]:checked');

      return {
        version: "1.4",
        cols: colsVal,
        rows: rowsVal,
        gridType: getGridType(),
        legendMode: getLegendMode(),
        labelMode: getLabelMode(),
        dashedLines: dashedLines.checked,
        crossBlack: crossBlack.checked,
        crossRed: crossRed.checked,
        crossFSI: crossFSI.checked,
        gridOnly: gridOnly.checked,
        imageOpacity: imageOpacity.value,
        gridOpacity: gridOpacity.value,
        codeOpacity: codeOpacity.value,
        borderWidth: borderWidthRadio ? borderWidthRadio.value : "normal",
        borderColor: borderColorEl.value,
        textColor: textColorEl.value,
        autoRefresh: autoRefresh.checked,
        orientationMode,
        zoom: zoomRange.value,
        fillColorDefault: fillColorEl.value,
        fillOpacity: fillOpacityEl.value,
        selectedCells,
        mergedRegions,
        currentRegionId
      };
    }

    function applyScenario(s, fromSheetSwitch = false) {
      if (!s) return;

      document.getElementById('cols').value = s.cols || 10;
      document.getElementById('rows').value = s.rows || 14;

      gridTypeSelect.value   = s.gridType || "fsi";
      legendModeSelect.value = s.legendMode || "full";
      labelModeSelect.value  = s.labelMode || "none";

      dashedLines.checked = !!s.dashedLines;
      crossBlack.checked  = !!s.crossBlack;
      crossRed.checked    = !!s.crossRed;
      crossFSI.checked    = !!s.crossFSI;

      gridOnly.checked    = !!s.gridOnly;

      imageOpacity.value  = s.imageOpacity ?? 100;
      gridOpacity.value   = s.gridOpacity ?? 100;
      codeOpacity.value   = s.codeOpacity ?? 100;

      const bwVal = s.borderWidth || "normal";
      const bwInputRadio = document.querySelector(`input[name="borderWidth"][value="${bwVal}"]`);
      if (bwInputRadio) bwInputRadio.checked = true;

      borderColorEl.value = s.borderColor || "none";
      textColorEl.value   = s.textColor || "";

      autoRefresh.checked = !!s.autoRefresh;
      updateAutoRefreshButton();

      orientationMode = s.orientationMode || "portrait";

      zoomRange.value   = s.zoom || 100;
      zoomNumber.value  = zoomRange.value;
      applyZoomScale();
      updateOrientationButton();

      fillColorEl.value   = s.fillColorDefault || "none";
      fillOpacityEl.value = s.fillOpacity || 35;

      selectedCells   = s.selectedCells || {};
      mergedRegions   = s.mergedRegions || [];
      currentRegionId = (typeof s.currentRegionId !== "undefined") ? s.currentRegionId : null;

      history = [];
      historyIndex = -1;

      if (fromSheetSwitch && sheets[currentSheetIndex]) {
        const dataUrl = sheets[currentSheetIndex].imageData || null;
        if (dataUrl) {
          const image = new Image();
          image.onload = function() {
            img = image;
            drawGrid();
            pushHistory();
            setMsg(`Feuille "${sheets[currentSheetIndex].name}" charg√©e (image + sc√©nario).`);
          };
          image.onerror = function() {
            img = null;
            drawBase();
            pushHistory();
            setMsg("Erreur de chargement d'image pour cette feuille.");
          };
          image.src = dataUrl;
        } else {
          img = null;
          if (gridOnly.checked) {
            drawGrid();
            pushHistory();
            setMsg(`Feuille "${sheets[currentSheetIndex].name}" sans image (grille seule).`);
          } else {
            drawBase();
            pushHistory();
            setMsg(`Feuille "${sheets[currentSheetIndex].name}" sans image : charge une image ou active "Grille sans image".`);
          }
        }
        return;
      }

      if (img || gridOnly.checked) {
        drawGrid();
        pushHistory();
        setMsg("Sc√©nario charg√©. La grille a √©t√© appliqu√©e.");
      } else {
        drawBase();
        pushHistory();
        setMsg("Sc√©nario charg√©. Il manque peut-√™tre l'image d'origine : charge-la puis clique sur APPLIQUER.");
      }
    }

    function saveScenarioJSON(filename = "quadrico_scenario.json", scenarioOverride = null) {
      const scenario = scenarioOverride || buildScenario();
      const blob = new Blob([JSON.stringify(scenario, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a   = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    loadScenarioBtn.addEventListener('click', () => {
      scenarioFileInput.value = "";
      scenarioFileInput.click();
    });

    scenarioFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          const data = JSON.parse(ev.target.result);
          applyScenario(data, false);
          if (sheets.length) {
            sheets[currentSheetIndex].scenario = data;
            refreshSheetSelect();
          }
        } catch (err) {
          console.error(err);
          setMsg("Erreur lors du chargement du sc√©nario (JSON invalide ?).");
        }
      };
      reader.readAsText(file, "utf-8");
    });

    /* ==== GESTION FEUILLES ==== */

    function refreshSheetSelect() {
      sheetSelect.innerHTML = "";
      sheets.forEach((sheet, idx) => {
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = sheet.name || ("Feuille " + (idx + 1));
        if (idx === currentSheetIndex) opt.selected = true;
        sheetSelect.appendChild(opt);
      });
    }

    function initSheets() {
      const baseScenario = buildScenario();
      sheets = [
        { name: "Feuille 1", scenario: baseScenario, imageData: null }
      ];
      currentSheetIndex = 0;
      refreshSheetSelect();
    }

    function switchToSheet(index) {
      if (index === currentSheetIndex) return;
      if (sheets[currentSheetIndex]) {
        sheets[currentSheetIndex].scenario = buildScenario();
      }
      currentSheetIndex = index;
      const s = sheets[index].scenario;
      applyScenario(s, true);
      refreshSheetSelect();
    }

    sheetSelect.addEventListener('change', (e) => {
      const idx = parseInt(e.target.value, 10);
      if (isNaN(idx)) return;
      switchToSheet(idx);
    });

    addSheetBtn.addEventListener('click', () => {
      if (sheets[currentSheetIndex]) {
        sheets[currentSheetIndex].scenario = buildScenario();
      }
      const baseScenario = buildScenario();
      const newIndex = sheets.length;
      sheets.push({
        name: "Feuille " + (newIndex + 1),
        scenario: structuredClone(baseScenario),
        imageData: null
      });
      currentSheetIndex = newIndex;
      refreshSheetSelect();
      applyScenario(sheets[newIndex].scenario, true);
      setMsg(`Nouvelle feuille "Feuille ${newIndex + 1}" cr√©√©e (sans image).`);
    });

    renameSheetBtn.addEventListener('click', () => {
      const sheet = sheets[currentSheetIndex];
      const newName = prompt("Nom de la feuille :", sheet.name || "");
      if (newName && newName.trim()) {
        sheet.name = newName.trim();
        refreshSheetSelect();
      }
    });

    // ‚ßâ : dupliquer la feuille actuellement affich√©e
    duplicateSheet1Btn.addEventListener('click', () => {
      if (!sheets.length || !sheets[currentSheetIndex].scenario) {
        setMsg("La feuille actuelle n'a pas encore de sc√©nario √† copier (applique un quadrillage d'abord).");
        return;
      }
      sheets[currentSheetIndex].scenario = buildScenario();

      const baseScenario = structuredClone(sheets[currentSheetIndex].scenario);
      const baseImage    = sheets[currentSheetIndex].imageData || null;
      const baseName     = sheets[currentSheetIndex].name || ("Feuille " + (currentSheetIndex + 1));

      const newIndex = sheets.length;
      sheets.push({
        name: "Copie " + baseName,
        scenario: baseScenario,
        imageData: baseImage
      });

      currentSheetIndex = newIndex;
      refreshSheetSelect();
      applyScenario(baseScenario, true);
      setMsg(`Feuille copi√©e depuis "${baseName}".`);
    });

    deleteSheetBtn.addEventListener('click', () => {
      if (sheets.length <= 1) {
        alert("Impossible de supprimer la derni√®re feuille.");
        return;
      }
      const sheet = sheets[currentSheetIndex];
      const ok = confirm(`Supprimer la feuille "${sheet.name}" ?`);
      if (!ok) return;
      sheets.splice(currentSheetIndex, 1);
      currentSheetIndex = Math.max(0, currentSheetIndex - 1);
      refreshSheetSelect();
      const s = sheets[currentSheetIndex].scenario;
      applyScenario(s, true);
      setMsg("Feuille supprim√©e.");
    });

    /* ==== COPIE / COLLE STYLE DE CASE ==== */

    function getCellStyleForCopy(c, r) {
      if (!lastGridGeom) return null;
      const key = `${c},${r}`;
      const base = selectedCells[key] || {};
      const region = findRegionByCell(c, r);

      let style = {
        borderColor: null,
        borderWidth: null,
        text: "",
        textColor: "",
        alpha: 1.0,
        fillColor: null,
        fillAlpha: null,
        noGrid: !!base.noGrid,
        noCode: !!base.noCode
      };

      if (region) {
        if (region.borderColor) style.borderColor = region.borderColor;
        if (region.borderWidth) style.borderWidth = region.borderWidth;
        if (region.text)       style.text        = region.text;
        if (region.textColor)  style.textColor   = region.textColor;
        if (typeof region.alpha === "number") style.alpha = region.alpha;
      }

      if (base.borderColor) style.borderColor = base.borderColor;
      if (base.borderWidth) style.borderWidth = base.borderWidth;
      if (base.text)        style.text        = base.text;
      if (base.textColor)   style.textColor   = base.textColor;
      if (typeof base.alpha === "number") style.alpha = base.alpha;
      if (base.fillColor)   style.fillColor   = base.fillColor;
      if (typeof base.fillAlpha === "number") style.fillAlpha = base.fillAlpha;

      const hasSomething =
        style.borderColor || style.borderWidth || style.text ||
        style.fillColor || style.noGrid || style.noCode;

      return hasSomething ? style : null;
    }

    function pasteCopiedStyle() {
      if (!copiedCellStyle || !lastClickedCell || !lastGridGeom) return;

      const { c, r } = lastClickedCell;
      const key = `${c},${r}`;
      const regionHere = findRegionByCell(c, r);
      const st = copiedCellStyle;

      pushHistory();

      if (regionHere) {
        regionHere.borderColor = st.borderColor || null;
        regionHere.borderWidth = st.borderWidth || null;
        regionHere.text        = st.text || "";
        regionHere.textColor   = st.textColor || "";
        regionHere.alpha       = (typeof st.alpha === "number") ? st.alpha : 1.0;

        for (const cell of regionHere.cells) {
          const k = `${cell.c},${cell.r}`;
          const existing = selectedCells[k] || {};
          if (st.noGrid) existing.noGrid = true; else delete existing.noGrid;
          if (st.noCode) existing.noCode = true; else delete existing.noCode;
          selectedCells[k] = existing;
        }
      }

      const existing = selectedCells[key] || {};
      selectedCells[key] = {
        ...existing,
        borderColor: st.borderColor || existing.borderColor,
        borderWidth: st.borderWidth || existing.borderWidth,
        text:        st.text,
        textColor:   st.textColor || existing.textColor,
        alpha:       (typeof st.alpha === "number") ? st.alpha : (existing.alpha ?? 1.0),
        fillColor:   (st.fillColor !== null ? st.fillColor : existing.fillColor),
        fillAlpha:   (typeof st.fillAlpha === "number" ? st.fillAlpha : existing.fillAlpha),
        noGrid:      !!st.noGrid,
        noCode:      !!st.noCode
      };

      drawGrid();
      setMsg("Style copi√© coll√© sur la case s√©lectionn√©e.");
    }

    /* ==== RACCOURCIS CLAVIER ==== */

    document.addEventListener('keydown', (e) => {
      const tag = e.target.tagName;
      const isInputField = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT');

      // Entr√©e = APPLIQUER
      if (e.key === 'Enter' && !isInputField) {
        e.preventDefault();
        drawGrid();
        return;
      }

      // Delete = reset derni√®re case cliqu√©e
      if (e.key === 'Delete') {
        if (lastClickedCell && lastGridGeom) {
          e.preventDefault();
          pushHistory();
          resetCell(lastClickedCell.c, lastClickedCell.r);
          drawGrid();
          setMsg("Case r√©initialis√©e (Suppr / Delete).");
        }
        return;
      }

      if (e.ctrlKey || e.metaKey) {
        const key = e.key.toLowerCase();

        if (key === 'z') {
          e.preventDefault();
          undoAction();
        } else if (key === 'c') {
          if (!lastClickedCell) return;
          e.preventDefault();
          const st = getCellStyleForCopy(lastClickedCell.c, lastClickedCell.r);
          if (st) {
            copiedCellStyle = st;
            setMsg("Style de la case copi√© (bordure / texte / zone / flags).");
          } else {
            setMsg("Aucune modification √† copier sur cette case.");
          }
        } else if (key === 'v') {
          if (!copiedCellStyle || !lastClickedCell) return;
          e.preventDefault();
          pasteCopiedStyle();
        }
      }
    });

    /* ==== GOOGLE MAPS ==== */

    mapsOpenBtn.addEventListener('click', () => {
      const addr = (mapsAddress.value || "").trim();
      let url;
      if (!addr) {
        url = "https://www.google.com/maps/";
        setMsg("Ouverture de Google Maps.");
      } else {
        url = "https://www.google.com/maps/search/?api=1&query=" + encodeURIComponent(addr);
        setMsg("Ouverture de Google Maps avec l'adresse saisie.");
      }
      window.open(url, "_blank");
    });

    /* ==== MENU EXPORT ==== */

    function closeExportMenu() {
      exportMenu.classList.add('hidden');
    }

    function toggleExportMenu() {
      exportMenu.classList.toggle('hidden');
    }

    exportMenuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleExportMenu();
    });

    document.addEventListener('click', (e) => {
      if (!exportMenu.contains(e.target) && e.target !== exportMenuBtn) {
        closeExportMenu();
      }
    });

    exportPngBtn.addEventListener('click', () => {
      closeExportMenu();
      downloadPNG();
    });

    function exportAsPDF() {
      closeExportMenu();
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† exporter : applique un quadrillage d'abord.");
        return;
      }
      try {
        if (!window.jspdf || !window.jspdf.jsPDF) {
          setMsg("Impossible de g√©n√©rer le PDF automatiquement dans ce navigateur.");
          return;
        }
        const { jsPDF } = window.jspdf;
        const orientation = canvas.width >= canvas.height ? 'l' : 'p';
        const pdf = new jsPDF({ orientation, unit: 'mm', format: 'a4' });

        const pageWidth  = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgData    = canvas.toDataURL('image/png');

        const imgAspect  = canvas.width / canvas.height;
        const pageAspect = pageWidth / pageHeight;

        let pdfWidth, pdfHeight;
        if (imgAspect > pageAspect) {
          pdfWidth  = pageWidth;
          pdfHeight = pageWidth / imgAspect;
        } else {
          pdfHeight = pageHeight;
          pdfWidth  = pageHeight * imgAspect;
        }

        const x = (pageWidth  - pdfWidth)  / 2;
        const y = (pageHeight - pdfHeight) / 2;

        pdf.addImage(imgData, 'PNG', x, y, pdfWidth, pdfHeight);
        pdf.save('quadrico_carte.pdf');
        setMsg("PDF export√© et t√©l√©charg√© (quadrico_carte.pdf).");
      } catch (e) {
        console.error(e);
        setMsg("Erreur lors de la g√©n√©ration du PDF.");
      }
    }

    exportPdfBtn.addEventListener('click', exportAsPDF);

    function exportGridOnlyScenario() {
      closeExportMenu();
      const scenario = buildScenario();
      const scenarioCopy = structuredClone(scenario);
      scenarioCopy.gridOnly = true;
      scenarioCopy.imageOpacity = 0;
      saveScenarioJSON("quadrico_quadrillage_seul.json", scenarioCopy);
      setMsg("Quadrillage enregistr√© (sans la carto) au format JSON.");
    }

    exportGridOnlyBtn.addEventListener('click', exportGridOnlyScenario);

    exportPrintBtn.addEventListener('click', () => {
      closeExportMenu();
      printWithSize("A4");
      setMsg("Fen√™tre d‚Äôimpression ouverte. La carto est centr√©e et l‚Äôorientation de la page est adapt√©e automatiquement √† la forme de la carte.");
    });

    // ====== ENVOI PAR MAIL (desktop vs mobile) ======
    function sendExportByEmail() {
      closeExportMenu();
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† envoyer : applique un quadrillage d'abord.");
        return;
      }

      const fileName = "quadrico_carte.png";
      const link = document.createElement('a');
      link.href = canvas.toDataURL("image/png");
      link.download = fileName;
      link.click();

      const subjectRaw = "QuadRico - Carte quadrill√©e";
      const bodyRaw =
        "Carte g√©n√©r√©e avec QuadRico.\n\n" +
        "Le fichier \"" + fileName + "\" vient d'√™tre t√©l√©charg√© sur ton appareil.\n" +
        "Merci de l'ajouter en pi√®ce jointe au mail avant envoi.";

      const subjectEnc = encodeURIComponent(subjectRaw);
      const bodyEnc = encodeURIComponent(bodyRaw);

      if (isMobileDevice()) {
        // T√©l√©phone / tablette : appli mail par d√©faut
        const mailtoUrl =
          "mailto:?subject=" + subjectEnc +
          "&body=" + bodyEnc;
        window.location.href = mailtoUrl;
        setMsg("PNG t√©l√©charg√©. Ouverture de ton application mail par d√©faut (ajoute le fichier en pi√®ce jointe).");
      } else {
        // Ordinateur : Gmail Web (ou handler configur√© pour ce type de lien)
        const url =
          "https://mail.google.com/mail/u/0/?view=cm&fs=1" +
          "&su=" + subjectEnc +
          "&body=" + bodyEnc;

        window.open(url, "_blank");
        setMsg("PNG t√©l√©charg√©. Gmail Web ou ton webmail par d√©faut s‚Äôouvre (ajoute le fichier en pi√®ce jointe).");
      }
    }

    exportMailBtn.addEventListener('click', sendExportByEmail);

    function sendExportByWhatsApp() {
      closeExportMenu();
      if (!canvas.width || !canvas.height) {
        setMsg("Rien √† envoyer : applique un quadrillage d'abord.");
        return;
      }

      const fileName = "quadrico_carte.png";
      const link = document.createElement('a');
      link.href = canvas.toDataURL("image/png");
      link.download = fileName;
      link.click();

      const text =
        "Carte g√©n√©r√©e avec QuadRico.\n\n" +
        "Le fichier \"" + fileName + "\" vient d'√™tre t√©l√©charg√© sur mon appareil.\n" +
        "Je vais l'ajouter en pi√®ce jointe √† ce message.";
      const url = "https://wa.me/?text=" + encodeURIComponent(text);
      window.open(url, "_blank");

      setMsg("PNG t√©l√©charg√©. WhatsApp s'ouvre pour envoyer le message (ajoute le fichier en pi√®ce jointe).");
    }

    exportWhatsappBtn.addEventListener('click', sendExportByWhatsApp);

    /* ==== AIDE / MODAL ==== */

    function openHelp() {
      helpOverlay.classList.remove('hidden');
    }
    function closeHelp() {
      helpOverlay.classList.add('hidden');
    }
    function openWelcome() {
      welcomeOverlay.classList.remove('hidden');
    }
    function closeWelcome() {
      welcomeOverlay.classList.add('hidden');
    }

    helpBtn.addEventListener('click', () => {
      closeWelcome();
      openHelp();
    });

    closeHelpBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeHelp();
    });

    helpOverlay.addEventListener('click', (e) => {
      if (e.target === helpOverlay) {
        closeHelp();
      }
    });

    closeWelcomeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeWelcome();
    });

    welcomeOverlay.addEventListener('click', (e) => {
      if (e.target === welcomeOverlay) {
        closeWelcome();
      }
    });

    window.addEventListener('load', () => {
      openWelcome();
      updateAutoRefreshButton();
      updateMobileOrientationClasses();
      updateOrientationButton();
    });

    /* ==== INIT ==== */

    initSheets();
  </script>
</body>
</html>
